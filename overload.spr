mod over

# Basic Resolution
def foo = (Int) {}
def foo = (Num) {}
def foo[T] = (T) {}
def foo[Foo] = (Foo) {}

# Resolution Failure
def bar = (Int) {}
def bar = (Num) {}
def bar = (Foo) {}

# Mutability
def baz = (mut Int, mut Int) {}
def baz = (Int) {}
def baz = (mut Int) {}

# Ambiguity
def raf = (Num, Int) {}
def raf = (Int, Num) {}
def raf[T] = (Int, T) {}

# Return type selection
def tst = (String) -> 3
def tst = (String) -> 3.3

# Return type selecton
def bac = (Int) -> 3.3
def bac = (Float) -> 3

# Cross-ambiguity
def res :: (Int) -> Int = (Int) -> 3
def res :: (Num) -> Num = (Num) -> 4

# Construction
def bal = (Foo, Int) {}
def bal = (Foo) {}
def bal = (Bar) {}

# Types for testing construction
def Foo = (String, Int) {
    static new = (String) -> .Foo(3)
}

def Bar = (Int) {       # default is impliict
    @explicit
    static new = (Float) -> .Int.Bar
}

# Generics Specialization
def foo = (Num) {}
def foo[T !: Sortable] = (T) {}
def foo[T] = (T) {}

def main = () {
    let y :: Float = tst("Hello")
    let x = bac(3)                  # bac(Int) -> Float
    let z :: Int = bac(3)           # bac(Float) -> Int
    let p = 3.bac.bac               # bac(Int) -> Float => bac(Float) -> Int
    #let w = bac(3) :: Float        Ambiguous if '::' performs type checking ?? I could call bac(Int) as return type doesn't matter

    # How do I get it to print int ??
    println("{:t}", bac(3))         # Assume ':t' means print the type

    # This is a true cross-match
    let l :: Num = res(3)
    ##
    (Num) -> Num matches return exactly, arg by polymorphism
    (Int) -> Int matches return by polymorphism, arg exactly
    ##


    #bal("#", 3)            Error: Ambiguous overload (construction)
    bal(("#", 3), 3)        # bal(Foo, Int)
    # bal(3.3)              Error: No overload found of bal(Float). Explicit constructor Bar(Float) found ?

    #raf(3, 3)              Error: Ambiguous overload (same-match)
    raf(3, 3.)              # raf(Int, Num)

    # Specialization
    foo(Array[T]:new)       # foo[T]
    foo(3)                  # foo(Num)
    foo('A')                # foo[!Sortable]
}