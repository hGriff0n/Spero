mod huffman
use std.{io, iter}.*

def Huffman = (probs :: Float*) {
    # The tree gets constructed automatically since it accepts a Float*
    let decoder = HuffmanHelper(probs) {
        def Reducer = Unk(String, String) | Knw(String) {}

		let mesg = .match {
			Knw(s) -> s
			_ -> Error{ "Could not decode the message" }
		}

        def help = (String) ->
            .reduce(Collect(""), (char, collector) {
                let msg = collector .match {
                    Unk(s, t) -> (s, t + char)
                    Knw(s) -> (s, char)
                }

                if (tree.hasLeafAt(msg._1))
                    Knw(msg._0 + tree.getLeafAt(msg._1))
                else
                    Unk(msg._0, msg._1)
            }).mesg
    }

    let encoder = HuffmanHelper(probs) {
        let help = (String) -> .fmap(tree.getCodeFor)            # Doesn't consider the 127 thing
    }

    static writeTo = (f :: File, d :: String) -> f.writeAll(data)
    static readFrom = (File) -> .readAll

    def encode = (in :: File, out :: File) {
        out .Huffman:writeTo(encoder.help(in .Huffman:readFrom))
    }

    def decode = (in :: File, out :: File) {
        out .Huffman:writeTo(decoder.help(in .Huffman:readFrom))
    }
}

let HuffmanHelper = (tree :: HuffmanTree) {
    def help :: (String) -> String
    def setTree = (...) { ... }
}

let HuffmanTree = (probs :: Float*) {
    let HuffmanNode = {						# Needs more work on interfaces and type implementations

    }
}