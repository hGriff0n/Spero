mod exercises:elementary

use std:{io, math}:_

def hello = () -> "Hello World".println

def who = () -> {
    let name = "Who are you? {}".getln                  # getln can be used to display prompts
    "Hello, {}!".println(name)                          # Don't need to restrict name to a type (println doesn't need it)
}

def alibob = () -> match "Who are you? {}".getln :: String {
    "Alice" -> "Hello, Alice!".println                  # Do I need to restrict the type that getln returns here?
    "Bob" -> "Hello, Bob!".println                      # Matching should be able to handle this automatically
    _ -> ()
}

def sum = () -> {
    let num :: Size = "Enter a number: {}".getln        # Definitely need to restrict typing here
    "Sum 1 to {}: {}".println(num, {1..num}.reduce(+, 0))
}

def modsum = () -> {
    let num = "Enter a number: {}".getln :: Size        # Can restrict in multiple ways
    "Sum 1 to {}: {}".println(num, {1..num}.filter((n) -> n % 3 == 0 || n % 5 == 0).reduce(+, 0))
}

def choice = () -> {
    "Enter a number: {}".getln :: Size
    getln("Do you want to calculate the product or the sum: ")
}

def printTable = () -> for i in 0..12 do {
    {0..12}.foreach((j) -> "{:4}".print(i * j))
    println
}

@todo("write this function")
def allprimes = () -> {
}

def guessingGame = () -> {
    let secret = rand :: Int
    let num_tries = mut 0

    {
        num_tries += 1
        let guess = "Enter a number: {}".getln :: Int

        # Preliminary conditional match syntax
        match guess {
            x .if x == secret -> break;
            x .if x < secret -> "Sorry. The secret number is higher than {}".println(x)
            x -> ("Sorry. The secret number is lower than {}", x).println
        }
    }.loop

    "Congratulations! It took you {} guesses".println(num_tries)
}

@todo("write function to calculate next 20 leap years")
def leapyears = () -> {}

@todo("Write function that computes '4\cdot \sum_{k=1}^{10^6} \frac{(-1)^{k+1}}{2k-1} = 4\cdot(1-1/3+1/5-1/7+1/9-1/11|dots)")
def compute = () -> {}