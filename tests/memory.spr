
mod mem:testing

use std:lang:mem

##
Design Goals of Memory Management:
    1) Have a way to mark and use sections of non-stack memory for implementation purposes
        Solution -> mem:alloc, mem:valloc
    2) Have a way to use specific sections of memory for implementation purposes
        Solution -> mem:Chunk(mem:Addr, Size)
    3) Have a way to enable reference semantics in function calls (ie. Java semantics)
        NOTE: Any place where this can be used is replacable with a type method. That solution isn't tenable for user code however.
    4) Have a way to type a sequence of elements
    5) Have a way to maintain typing on a sequence of differently-typed elements

    Development Process:
        Come up with many possibilities
            There's several ways that an interface can work
            Pick one, and then develop everything based around that central idea
            Repeat for each interface before culling them to one form that works the best
##

##
TODO:
  Look into adding the ability for "inline mut" (for making a value mutable for function purposes)
    The grammar already accepts it, this just gives meaning to the construction
  Work on the semantics of getting a 'T' from 'Chunk' (`Element[T]`)
  Update the grammar to match the changes
    Look into adding '_' for creating lambdas (analysis stage ???)
    Look into moving 'mut' into the binding area
    Change "view" from 'T*' to 'T..'
    Add 'T..' variadics support to generics grammar
    Allow for a block after impls statement (for putting in the impls declarations)
  Look into allowing 'name = val' syntax inside of impls blocks (not require visibility requirement to meet interfaces)
  Look into a way to transform a stack value into a memory operable value
  Figure out how drop will be implemented
    What will Chunk:drop do?
      It can't call destructors because Chunk doesn't know what it has
  'T..' isn't an exact replacement for 'T*' ???
##

##
This function should:
    Allocate enough space to store 4 Ints
    Set the first Int to 1 and the third to 3
    Sum the Ints in the stored space
    Deallocate the store
##
@safe("Because")
def intArrayTest = () -> {
    let chnk = mut mem:alloc(Int.size * 4)          # Allocate space for 4 Int's. Returning a 'Chunk' allows for more intuitive operations

    let fst = mut chnk.view_as[Int]                 # Make 'fst' refer to the first Int in 'chnk's region of memory
    fst = 1                                         # Would 'chnk' have to be mutable for this operation ???

    let thd = mut chnk(2 * Int.size).view_as[Int]   # These semantics ("Element[T] = T") is currently unstable as I'm not sure
    thd = 3                                         # How interchangeable a "Element[T]" should be with a "T". This implies very

    # Should equal '4' as 'alloc' zero-initializes
    {0..4}.map!(chnk.view_as[Int](_)).reduce(+, 0)  # I have a 'for_each' function that does roughly this, but not quite

    # 'Chunk:drop' automatically frees the memory when the function exits
}

##
This function should:
    Allocate a 5 on the heap and enough space to store 2 Ints
    Intitialize the 2 Ints to allocated 5
    Deallocate both chunks
##
@todo("Update the interface to the current 'Memory[T]' standard")
@safe("No leakage can happen with Integers and all allocated memory is released")
def initTest = () -> {
    let ptr = mem:valloc(5)                     # Note: Seperate function needed in order to allow inference for 'Size' type
    let mem = mut mem:alloc[Int](2)             # Same as "mem:alloc(Int.size * 2)". What effect does this have on system safety
                                                # IDEA: 'chnk.transmute(0)' would make a variable at the address of the first Int ???

    # chnk.set[Int](ptr.view)
    chnk.view_as[Int] = ptr.get                 # 'malloc' returns an "Element". `view` doesn't need typing
    chnk.set[Int](1, ptr.view_as[Int].get)      # Since 'Element' :: 'Chunk', either method is fine to use
                                                # I'm not sure of the usefulness and sustainability of 'set'
}

##
This function should, given the address of a MMIO device:
    Create a pointer to it
    Initialize it's memory with 35
    Exit, leaving the 35 in memory
##
@safe("Because")
def wrap = (mmio :: mem:Addr) -> {
    let device = mut mem:Chunk(mmio, 4)     # Chunk needs to have a bound for it's "control"
    device.view_as[Size] = 35
    # device.view_as[Size].set(35)
    device.forget                           # Call 'forget' to prevent 'mmio' from being marked "free" in 'drop'
                                            # This interface makes memory safety the default behavior of Spero
                                            # You have to try to get the memory "unsafe" behavior
}

##
This function should:
    Accept an infinite sequence of Ints
    Return the sum of the ints
##
def sum[T] = (T..) -> .reduce(+, T)          # "T.." -> range of Ts

##
This function should, given a type 'T':
    accept a sequence of arguments (from various types)
    construct a T from the passed arguments
    produces a nice compiler error if no T can be constructed from the arguments (TODO)
##
def forward[T, Arg..] = (args :: Arg..) -> .T       # This doesn't read entirely right to me
    # Requires some tweaks to the generics grammar
    # Arg = [T1, T2, T3, ...]
    # args = (t1 :: T1, t2 :: T2, t3 :: T3, ...)
        # Is 'args' expanded as the whole tuple or an "Iterable[T]"
        # Will need a simple way to unpack to implement forward for the later

##
This function should:
    Using the previous 'forward' function
    Construct two instances of TestType using different constructors
    Assert that the different constructors were successfully called
##
let TestType = (z :: Int) {
    def isInt = mut true

    static new = (f1 :: Float, f2 :: Float) {
        let t = mut TestType(f1 + f2 / 2)
        t.isInt = false
    }
}
let useFwd = () -> {
    let t1 = 3.forward[TestType]
    let t2 = forward[TestType](3.4, 5.2)

    @assert!(t1.isInt != t2.isInt, "forward doesn't work as expected")
}
# TODO: How would a compiler error be produced if T(Arg..) isn't a valid construction


##
The best pointer interface I have
    Note: This doesn't work at all
##
def bestPtr = () -> {
    let ptr = mut mem:malloc(5)                 # Make a mutable pointer
    let o_ptr = mem:malloc(5)                   # Make an immutable pointer
                                                # Note: Pointers are not reassignable

    # IDEA: o_ptr.swap(ptr) for reassigning pointers

    # head.into_iter(.next).map!(.value).reduce(+, head.value)
    # Some pointer methods: borrow, copy, deref (special)

    # As I've changed views to be 'T..' syntax
        # Can I use '*' for pointers now ???
    # T& - ipointer to immutable T
    # mut T& - ipointer to mutabe T
    # T* - mpointer to immutable T
    # mut T* - mpointer to mutable T
}

##
This function should:
    Create a varaible on the stack
    From that variable create a Chunk object
    Modify the variable through the Chunk
##
def stackTest = () -> {
    let tst = 5

    # Get a way to modify tst without touching it
    mem:Chunk(@addrof!(tst), tst.sizeof)        # Turning to annotations makes safety a bit hard to check (possibly)
    mem:stackChunk(tst)                         # I don't know how possible this would be to code
    @stack!(tst)                                
}


def refTest[T] = (tst :: mut T&) {              # Have Java-style semantics of Pointers
    tst += 5                                    # Or C++ References in some aspects
}

def tst = () -> {
    let tst = 5
    refTest(tst.ref)                            # However, code needs to explicitly release control over the resource
                                                # For correctness. This also enables some compilation checks

    let ptr = mem:malloc(5)
    refTest(ptr)                                # Explicit 'malloc' pointers don't necessarily need to have this "borrowing"
                                                # Though there are some different issues that this may introduce
}

# Or I could fall back on the 'mut' overloading

def mutator = (i :: mut Int&) -> i *= 3
def keeper = (i :: Int&) -> i * 3
def tst = () -> {
    let me = 5
    mutator(me)         # error
    keeper(me)

    let me = me
    mutator(me)
    keeper(me)
}
# But how do I ensure that copies are created when they should be (ie. in type constructors)