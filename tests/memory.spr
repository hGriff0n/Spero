
mod mem:testing

use std:lang:mem

##
Design Goals of Memory Management:
    1) Have a way to mark and use sections of non-stack memory for implementation purposes
        Solution -> mem:alloc, mem:valloc
    2) Have a way to use specific sections of memory for implementation purposes
        Solution -> mem:Chunk(mem:Addr, Size)
    3) Have a way to enable reference semantics in function calls
        Solution -> T&, mut T& (C++ style references)
    4) Have a way to type a sequence of elements
    5) Have a way to maintain typing on a sequence of differently-typed elements
    6) Have a way to create links to non-stack memory usable at a public level

    Development Process:
        Come up with many possibilities
            There's several ways that an interface can work
            Pick one, and then develop everything based around that central idea
            Repeat for each interface before culling them to one form that works the best

    Accepted Language Changes:
        Changing "view" typing from 'T*' to 'T..'
        Adding 'T..' variadic support to generics
        Allow for a '{}' block after an 'impls' statement
            The block contains implementations for the 'impls' type
        Allow for "let-in" style bindings by allowing an 'in <expr>' in assignments
            Note: This will likely also require adding an ast node
        Update 'use' to allow for rebinding generic instantiated types
            Allow for "use Vector[Int] as IVector" 
        Add in "inline mut" into the language and be sure the ast recognizes it
            I'm pretty sure the grammar recognizes as a by-product of recognizing `ValExpr`
        Change operator precedence rules so that '&' operators have one precedence
    
    Parser TodoList Aditions:
        Be sure to setup ast and analysis to recognize (and mark) assignments of the form "let t = v"
##

##
TODO:
  Work on the semantics of getting a 'T' from 'Chunk' (`Element[T]`)
  Look into moving 'mut' into the binding area
  Look into adding '_' for creating lambdas (analysis stage ???)
  Resolve the issue with 'Memory[T]' and 'Element[T]'
  Look into tweaks to the 'impls' statements regarding the '{}' addition
    Requiring the '{}' and that implementations are in the block
    Dropping the 'def/let/static' keyword for matching implementations (impls is about giving meaning, the visibility is already specified)
  Figure out how drop will be implemented
  'T..' isn't an exact replacement for 'T*' ???
  Figure out what to do with 'mem:valloc' (return, deallocation of return)
    Changed 'Element[T]' to not have a drop method and that possibly introduces a memory leak with 'valloc'
  Work on the 'Memory'/'Chunk' interface interaction
  Add ability to destruct ADTs by reference within match statements (ie. "Some(mut& p)")
  Figure out where references are allowed to exist (my current idea is only in parameter lists)
##


# 1,2: Designing the raw memory interface

##
'std:mem:Chunk' interface:
  This is the lowest level interface (excepting maybe Addr) that Spero provides into raw memory
  A `Chunk` is an owned, contiguous section of bytes that are untyped by default. Normally created through a call to 'mem:alloc'
  Various operations are provided to manipulate these bytes as the programmer desires
  Some operations are also provided to allow a more "type"-ful interaction into these manipulations
##
@safe("Allocations are dropped before function exit. Return does not leak references to dropped values")
def intArrayTest = () -> {
    let chnk = mut mem:alloc(Int.size * 4)          # Allocate space for 4 Int's. Returning a 'Chunk' allows for more intuitive operations
    # let chnk = mut mem:alloc(Int, 4)

    let fst = mut chnk.view_as[Int]                 # Make 'fst' refer to the first Int in 'chnk's region of memory
    fst.set(1)                                      # Would 'chnk' have to be mutable for this operation ???

    let thd = mut chnk(2 * Int.size).view_as[Int]   # These semantics ("Element[T] = T") is currently unstable as I'm not sure
    # let thd = mut chnk(2, Int).view_as[Int]       # Depending on how raw types work, this may be possible
    # let thd = mut chnk[Int](2).view_as[Int]       # I know this works, just is it feasible to do the analysis
    thd = 3                                         # How interchangeable a "Element[T]" should be with a "T". This implies very

    # Should equal '4' as 'alloc' zero-initializes
    {0..4}.map!(chnk.view_as[Int](_).get).reduce(+)

    # 'Chunk:drop' automatically frees the memory when the function exits
}

##
'std:mem:Memory[T]' interface:
  `Chunk` has no conception of types by default by design, it is just a collection of contiguous bytes in memory, nothing else
  From a language standpoint however, Spero puts a lot of focus on types and working with them instead of raw bytes in memory
  To that end, `Chunk` needs a way to interact with it's byte sequence (or sub-sequence) in a type-safe(or -knowledgeable) way
  That is the purpose of `Memory[T]` (name TBD), one step up the abstraction ladder from `Chunk` (though it's still not good enough)
##
@todo("Update the interface to the current 'Memory[T]' standard")
@safe("No leakage can happen with Integers and all allocated memory is released")
def initTest = () -> {
    let ptr = mem:valloc(5)                     # Note: Seperate function needed in order to allow inference for 'Size' type
    let chnk = mut mem:alloc[Int](2)            # Same as "mem:alloc(Int.size * 2)". What effect does this have on system safety
                                                # IDEA: 'chnk.transmute(0)' would make a variable at the address of the first Int ???

    # chnk.set[Int](ptr.view)
    chnk.view_as[Int] = ptr.view_as[Int].get    # 'valloc' doesn't return an 'Memory[T]' as 'Memory[T]' has no 'drop' method (return `Element[T]`?)
    chnk.set[Int](1, ptr.view_as[Int].get)      # Since 'Memory' :: 'Chunk', either method is fine to use
                                                # I'm not sure of the usefulness and sustainability of 'set'
}

##
'std:mem:Chunk' in relation to memory mapped devices:
  The `Chunk` interface is also usable in relation to pre-existing addresses, albeit with some trepedation
  Given a `std:mem:Addr`, a Chunk can be created by simple construction, passing the address and the size
  One stipulation to use in this strategy is that a 'forget' call must be inserted before the chunk is dropped (can't put in constructor for mem:alloc implementation)
  This is especially necessary if the address is reserved from the allocator, as Chunk:drop frees it for future allocation
##
@safe("Because")
def wrap = (mmio :: mem:Addr) -> {
    let device = mut mem:Chunk(mmio, 4)     # Chunk needs to have a bound for it's "control"
    # let device = mut mem:MemRef(mmio, 4)  # Might be able to make a separate type instead (having explicit call to forget is potentially unsafe)

    device.view_as[Size] = 35               # You can use '=' or 'set' for setting an 'Memory[T]'
    # device.view_as[Size].set(35)          # Though I think 'set' may be more idiomatic

    device.forget                           # Call 'forget' to prevent 'mmio' from being marked "free" in 'drop'
                                            # This interface makes memory safety the default behavior of Spero
                                            # You have to try to get the memory "unsafe" behavior
}


# 4,5: Designing the variadic typing interface

##
Language Atom (views):
  Views are a simple way of accepting a sequence of values, from a variety of syntaxes
  From a semantics standpoint, a `T..` is equivalent to a 'std:util:Iterable[T]` but with some tweaks
  For one, when used at the end of a function body, it allows to function to accept a variadic sequence of arguments
  The "leftover" arguments are collected into a single Iterable body, generally an Array, for usage in the function
  Of course, calling the function with an Iterable[T] is still allowed, though it prevents the variadic semantics
##
def sum[T] = (T..) -> .reduce(+, T)          # "T.." -> range of Ts

##
Language Atom (variadics):
  Views are a great way to save a lot of typing in some instances, especially for their flexibility
  However, with the usage of views, we run into issues where the sequence of types is unknown to the programmer
  It may be possible to perform this acceptance pattern using a 'Any'-style view, but that sacrifices type safety
  Variadics are a way of extending the generics system to allow for these views, while maintaining type information

  TODO: Get a better idea of what makes variadics work, how to implement them
  TODO: Produce a nice compiler error if the usage of variadics cause an invalid construction
##
def forward[T, Arg..] = (args :: Arg..) -> .T       # This doesn't read entirely right to me
    # Requires some tweaks to the generics grammar
    # Arg = [T1, T2, T3, ...]
    # args = (t1 :: T1, t2 :: T2, t3 :: T3, ...)
        # Is 'args' expanded as the whole tuple or an "Iterable[T]"
        # Will need a simple way to unpack to implement forward for the later

##
Language Atom (variadics):
    Variadics are likely to drift from the initial goal of a "typed"-view into a C++-style mechanism
    This conception allows for forwarding functions in a very compact (but type-safe) typing
    However, this does bring sum issues as to what variadics are, a Tuple seems to match better than an Iterable
##
let TestType = (z :: Int) {
    def isInt = mut true

    static new = (f1 :: Float, f2 :: Float) {
        let t = mut TestType(f1 + f2 / 2)
        t.isInt = false
        t
    }
}
let useFwd = () -> {
    let t1 = 3.forward[TestType]
    let t2 = forward[TestType](3.4, 5.2)

    @assert!(t1.isInt != t2.isInt, "forward doesn't work as expected")
}
# TODO: How would a compiler error be produced if T(Arg..) isn't a valid construction



# 3,6: Designing the reference/pointer interface model

##
Idea 1: 'Mut'-infused pointers
    The idea for this interface is that 'mut' determines whether the pointers object is mutable
    The problem is in simultaneously preventing reassignment of the pointer when not desired
        Pointers are either mutable+moveable or neither, no in-between
        No way to prevent holding pointers in mutable and immutable modes
##
def ptrTest = () -> {
    let ptr = mut mem:malloc(5)                 # Make a mutable pointer
    let o_ptr = mem:malloc(7)                   # Make an immutable pointer
                                                # Note: Pointers are not reassignable

    # Reassigning pointers
    ptr.swap(mut o_ptr)                         # This switches what 'ptr' and 'o_ptr' point to
                                                # Wouldn't this imply that '=' is overloaded to assign to the pointed object ???

    # let tst = ptr                             # error: Immutable+Mutable pointers to the same locations (how on earth do I determine that ???)
                                                # I know of no feature in the language that would catch and prevent this error from compiling
                                                # Standard 'mut' rules should handle switching, but they do nothing when multiple references are in play
                                                # 'mut' rules actually do catch this when determining whether to copy or alias a binding (though I don't know if that's still a thing)
    let tst = ptr.borrow                        # This method prevents using 'ptr' while test is in scope (still holding the borrow)
                                                # Think a bit of Rust's "ownership" concept in this regards (there's a 'borrow_mut' method too)
    let tst = o_ptr                             # No problem. Should also drop the previous pointer if any was created (releasing ownership in our case)
    
    # TODO: What should happen here ???
    let t = 5
    swap(ptr, t)
    

    # Way to create pointers from pre-allocated memory
    let ptr_pool = mut mem:alloc(8)
    let ptr1 = mem:mk_ptr_from[Int](ptr_pool)           # 'mk_ptr_from' takes a Chunk and creates a pointer for the given memory and type
    let ptr2 = mem:mk_ptr_from[Int](ptr_pool(4))        # TODO: Need to figure out memory-ownership (pointer or chunk, how would I handle pointer?)
                                                        # TODO: Also prevent 'null' pointers within this conception 


    # IDEA: &-operators perform pointer arithmetic
    @assert!(ptr1 &+ 1 == ptr2)

    # Modifying the pointed object is simple with the 'deref' special method
    ptr += 5
    o_ptr += 3                                  # error: 'attempt to mutate an immutable object'
                                                # it may be a bit difficult defining 'deref' to enable these semantics
}

##
Idea 2: Mutable+Immutable Pointer types
    The idea is that the distinction between mutable pointed objects and mutable pointers can be enforced through separate types
    One type would represent immutable pointed objects while the other would allow mutation of the pointed objects, 'mut' remains as is
    The problem is one of complexity and naming, it's much more difficult to express the idea of two unique pointer types to a learner
    That may be a benefit, but I also have a difficult time in coming up with correct names and figuring out the interaction between the 2

    With this idea you get mutability separation as desired (and the language requires) without any special effort
        However, this comes at the cost of typing (and possibly name) complexity, especially when trying to convert between the two
    I'm not actually sure I can prevent the mutability issue, even with this idea
##
def ptrTest = () -> {
    let ptr = mem:malloc(5)
    let o_ptr = mut mem:calloc(7)

    # Reassigning pointers (including between mutability)
    o_ptr.swap(mut ptr)                                 # This should not be an issue unless the pointers have multiple references (mutability clash)
                                                        # Swapping between pointers of the same mutability should not be an issue, period
                                                        # Should this be an error among different mutabilities ???

    # let tst :: MPtr[Int] = o_ptr
    let tst = o_ptr.borrow_as_mut                       # borrow 'o_ptr' as mutable, error if references isn't 1
    let tst = ptr                                       # Releases 'o_ptr' borrowing. No typing problem because of the borrowing

    # Typing of the pointer types
    let tst :: Ptr[Int] = o_ptr
    let tst :: MPtr[Int] = ptr                          # I don't like the 'mutable pointer' typing, but these are the best I have at the moment


    # Creating pointers from memory pool (ie. Chunk)
    let ptr_pool = mut mem:alloc[Int](2)
    let ptr1 = mem:mk_mptr_from[Int](ptr_pool)          # Special methods to create mutable spointer
    let ptr2 = mem:mk_ptr_from[Int](4.ptr_pool)


    # Modifying pointed objects (and pointer arithmetic)
    @assert!(ptr1 &+ 1 == ptr2)                         # Would this work as 'ptr1' and 'ptr2' are of different mutabilities? They might be incomparable

    ptr1 += ptr                                         # This may be a bit difficult to type correctly with the implicit 'deref' calls
    o_ptr += 3                                          # error: 'attempt to mutate an immutable object'
}

def List = {
    def next :: Option[Ptr[List]] = None
    def val = mut 5
}

def workWithList = (l :: List&) -> {
    match l.next {
        Some(p) -> p.borrow_as_mut += 3                 # I need to be sure that I can actually prevent this mutability issue
        None -> return
    }
}

##
Idea 3: Mutable-only pointers
    The idea is that the pointed objects of all pointers is mutable, regardless of the mutability of the pointer
    The main problem with this approach is that it just ignores the mutability issue entirely
        This is a marked departure from the rest of the language and may make some guarantees impossible
            Namely immutability is right-out if any pointers are used as an implementation detail (without effort)
        However, it manages to solve the main problem with Idea 1 and mutability, namely the inability to catch issues
##
def ptrTest = () -> {
    let ptr = mut mem:malloc(5)
    let o_ptr = mem:malloc(7)

    # Reassigning pointers
    ptr.swap(mut o_ptr)                                 # It seems the reassignment interface is pretty good among the options
    let tst = ptr.borrow                                # Preventing mutability is not an issue because there everything is mutable
    let tst = o_ptr                                     # Borrow is just an extra method to prevent using 'ptr' while 'tst' exists (in it's borrowing form)


    # Creating pointers from a memory pool (ie. Chunk)
    let ptr_pool = mut mem:alloc[Int](2)
    let ptr1 = mut mem:mk_ptr_from[Int](ptr_pool)
    let ptr2 = mem:mk_ptr_from[Int](4.ptr_pool)


    # Modifying pointed objects (and pointer arithmetic)
    @assert!(ptr1 &+ 1 == ptr2)

    ptr1 += ptr
    o_ptr += 3                                          # Allowed as all pointerd objects are "mutable"
}


# IDEA 1: use 'malloc/calloc' as differentiators between reassignable pointers
    # But that means that 't = mut t' no changes mutability status, possible prolbe
# IDEA 2: use 'malloc/calloc' as differentiators between mutability status of the owned memory
    # But then 't = mut t' can move the pointer around, that is itself an error state
def PointerTestClass = {
    let r = mut mem:malloc(3)       # r :: mut Size mut*
    let p = mem:calloc(4)           # p :: Size*

    # Prolbems if it returns a 'mut Size*' -> error (at least if non-mutable function returns mutable pointer)
    def getR = () -> r

    @mutable
    def getMutR = () -> r           # Should I require a 'mut' here
}


##
Syntax Idea: Kinda follows a bit from the Rust syntax (I believe)
##
def mcfoo = (p :: mut T*) -> ()
def mmfoo = (p :: mut T mut*) -> {}
def cmfoo = (p :: T mut*) -> ()
def ccfoo = (p :: T*) -> {}
def ptrTest = () -> {
    let ptr = mut mem:malloc(5)                 # Make a mutable pointer
    let o_ptr = mem:malloc(7)                   # Make an immutable pointer
                                                # Note: Pointers created with `ralloc` are reassignable

    # Reassigning pointers
    # ptr.swap(mut o_ptr)                       # Error: Attempt to reassign `ptr` and `o_ptr` obtained from call to `calloc`

    # (mut->const,diff,ptr) reassignment ==> error (current behavior)
    # let tst = ptr                             # error: Immutable+Mutable pointers to the same locations (how on earth do I determine that ???)
                                                # I can use mut-reassignment checking rules, to insert some checking code
    let tst = ptr.borrow                        # This method prevents using 'ptr' while test is in scope (still holding the borrow)
                                                # Think a bit of Rust's "ownership" concept in this regards (there's a 'borrow_mut' method too)
                                                # I need to think about it's interaction with number of references
    let tst = o_ptr                             # No problem. Should also drop the borrowing of `ptr`
    
    # Swap out the value
    let t = 5
    swap(ptr, t)
    

    # Way to create pointers from pre-allocated memory
    let ptr_pool = mut mem:alloc(8)
    let ptr1 = mem:mk_ptr_from[Int](ptr_pool)           # 'mk_ptr_from' takes a Chunk and creates a pointer for the given memory and type
    let ptr2 = mem:mk_ptr_from[Int](ptr_pool(4))        # TODO: Need to figure out memory-ownership (pointer or chunk, how would I handle pointer?)
                                                        # TODO: Also prevent 'null' pointers within this conception
                                                        # Note: `mk_ptr_from` should to return calloc pointers


    # IDEA: &-operators perform pointer arithmetic
    @assert!(ptr1 &+ 1 == ptr2)                 # You don't need to have `mut*` to perform arithmetic, only to reassign

    # Modifying the pointed object is simple with the 'deref' special method
    ptr += 5
    o_ptr += 3                                  # error: 'attempt to mutate an immutable object'
                                                # it may be a bit difficult defining 'deref' to enable these semantics
}


##
Some additional pointer work
    deref - special method for accessing the pointed object when needed, automatically inserted by the language
    copy - method to create a new pointer that is a copy of the original (not linked in terms of references, etc.)
##


##
Language Atom (references):
  The standard Spero execution model requires an explicit pass-by-value model for arguments, copying where needed
  This disallows some useful ways of programming (with side-effects and memory efficiency), mostly in regards to OOP methods
  To this end, Spero allows 'T&' syntax to indicate a pass-by-reference "reference" ala C++ (switch the mutability though)
  A raw 'T&' is really only good for preventing accidental copying. Compilers may be allowed to add '&' in analysis/optimization for this reason
  Changing to 'mut T&' allows for the same mutability rules as 'mut T', but with the added benefit that changes propogate to the callee
  
  TODO: Figure out what to do with 'mutator(mut 3)'
##
def mutator = (i :: mut Int&) -> i *= 3         # 'T&' takes on C++-style reference semantics with largely no changes
def keeper = (i :: Int&) -> i * 3
def tst = () -> {
    let me = 5
    # mutator(me)                               # "error" - attempt to take a mutable reference to an immutable object
    mutator(mut me)                             # 'inline mut' syntax can get around this issue
    keeper(me)                                  # But isn't this standard '(T)' behavior? Avoids copying unnecessarily
                                                # Copying only occurred in using a 'T' for a '(mut T)'
                                                # I could make that an optimization instead of a requirement

    let me = mut 5
    mutator(me)
    let me = keeper(me)                         # 'me == 45'

    # Idea: Allow pointers to be interchangeable with 'T&' (mut pointers with 'mut T&')
}
# Note: This is currently using the "two pointers" idea (even if there is a "sugary" syntax available)
def ptrRef = (p :: mut IPtr[Int]&) -> {}        # You can take pointers by reference ???
def mptrRef = (p :: mut Ptr[Int]&) -> {}        # This wouldn't "invoke" reference counting, possibly more efficient
                                                # The mutability problem remains though