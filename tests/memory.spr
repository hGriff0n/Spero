
mod mem:testing

use std:mem

##
Design Goals of Memory Management:
    1) Have a way to mark and use sections of non-stack memory for implementation purposes
        Solution -> mem:alloc, mem:valloc
    2) Have a way to use specific sections of memory for implementation purposes
        Solution -> mem:Chunk(mem:Addr)
    3) Have a way to enable reference semantics in function calls (ie. Java semantics)
        NOTE: Any place where this can be used is replacable with a type method. That solution isn't tenable for user code however.
    4) Have a way to type a sequence of elements
    5) Have a way to maintain typing on a sequence of differently-typed elements
##

##
TODO:
  Think about moving 'mut' into the binding area
  Provide a way to get raw memory data?         <- What?
  Should 'Chunk' be a mutable-only type?
  Look into adding the ability for "inline mut" (for making a value mutable for function purposes)
  Look into adding '_' lambda creation
  Work on the semantics of 'Chunk1' to enable it's usage in 'view_as'
    The current semantics also move 'Chunk1[T]' into the realm of 'T&'
    Maybe make 'view_as' return a different type (it shouldn't own the memory, drop behavior)
##

##
This function should:
    Allocate enough space to store 4 Ints
    Set the first Int to 1 and the third to 3
    Sum the Ints in the stored space
    Deallocate the store
##
def intArrayTest = () -> {
    let chnk = mut mem:alloc(Int.size * 4)          # Allocate space for 4 Int's. Returning a 'Chunk' allows for more intuitive operations

    let fst = mut chnk.view_as[Int]                 # Make 'fst' refer to the first Int in 'chnk's region of memory
    fst = 1                                         # Would 'chnk' have to be mutable for this operation ???

    let thd = mut chnk(2 * Int.size).view_as[Int]   # These semantics ("Chunk1[T] = T") is currently unstable as I'm not sure
    thd = 3                                         # How interchangeable a "Chunk1[T]" should be with a "T". This implies very

    # Should equal '4' as 'alloc' zero-initializes
    {0..4}.map(chnk.view_as[Int](_)).reduce(+, 0)

    # 'Chunk:drop' automatically frees the memory when the function exits
}

##
This function should:
    Allocate a 5 on the heap and enough space to store 2 Ints
    Intitialize the 2 Ints to allocated 5
    Deallocate both chunks
##
@safe("No leakage can happen with Integers and all allocated memory is released")
def initTest = () -> {
    let ptr = mem:valloc(5)                     # Note: Seperate function needed in order to allow inference for 'Size' type
    let mem = mut mem:alloc[Int](2)             # Same as "mem:alloc(Int.size * 2)". What effect does this have on system safety
                                                # IDEA: 'chnk.transmute(0)' would make a variable at the address of the first Int ???

    # chnk.view_as[Int] = ptr                   # What would this imply?
    # chnk.view_as[Int].set(ptr.view)
    chnk.view_as[Int] = ptr.view                # 'malloc' returns a "Chunk1". `view` doesn't need typing
    chnk.set[Int](1, ptr.view_as[Int])          # Since 'Chunk1' :: 'Chunk', either method is fine to use
                                                # I'm not sure of the usefulness and sustainability of 'set'

    # Note: 'drop' works for both due to the inheritance relation
}

##
This function should, given the address of a MMIO device:
    Create a pointer to it
    Initialize it's memory with 35
    Exit, leaving the 35 in memory
##
def wrap = (mmio :: mem:Addr) -> {
    let device = mut mem:Chunk(mmio, 4)     # Chunk needs to have a bound for it's "control"
    device.view_as[Size] = 35
    device.forget                           # Call 'forget' to prevent 'mmio' from being marked "free" in 'drop'
                                            # This interface makes memory safety the default behavior of Spero
                                            # You have to try to get the memory "unsafe" behavior
}

##
def foo = (b :: mut Int) -> {}      <- This means that b is mutable <b>in the context of 'foo'</b>
def bar = mut 3                     <- This means that bar is mutable <b>in the current context</b>
foo(bar)                            <- What does this mean then ???
##

##
This function should:
    Allocate a variable initialized to 3        <- Wherever is necessary to get the semantics
    Print the value of the variable
    Pass that variable to a function which should:
        Allocate a Chunk on the stack initialized to the variable
        Double the passed variable, ensuring changes propogate to the caller
        Return the allocated chunks
    Print the value of the chunk and the variable
    Deallocate the chunk and the variable
##
def mutProp = () -> {
    # Allocate
    "{}".println(...)

    let chnk = mutArgs(...)
    "{} -> {}".println(chnk.view_as[...], ...)

    # Values should be automatically dropped here
}
def mutArgs = () -> {
    let chnk = mut mem:valloc(...)
    # Double the passed argument
    chnk
}