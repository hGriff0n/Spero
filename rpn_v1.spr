##
# A little test program to help work out the vs-spero extension and for settling the function syntax
# The test program is primarily a basic RPN calculator with some non-rpn functions
##

mod rpn
use std:{io, str}:*

def main = getln .parse .println("= {}")

type Stack[T] = Empty | Cons(T, Stack) {
	def toStr = self .match {
		Cons(i, Empty) => i.toStr
		_              => "nil"
	}
}

let parse = (:String)
	.groupWhile(isDigit)
	.removeIf(isSpace)
	.reduce(Empty, (a, b) .match {
		Cons(r, Cons(l, _s)), "+" => Cons(l + r, _s)
		Cons(r, Cons(l, _s)), "-" => Cons(l - r, _s)
		Cons(r, Cons(l, _s)), "/" => Cons(l / r, _s)
		Cons(r, Cons(l, _s)), "*" => Cons(l * r, _s)
		Cons(l, _s), "~"          => Cons(-l, _s)
		s, _                      => Cons(_.toInt, s) 
	})._1									# A minor problem with the current proposal (the '_1')

# Comment for consistency with `rpn_v2.spr`
let eval = (:Stack[Int]) .match {
	Cons(i, Empty) => i.toStr
	_              => "nil"
}

let Cipher[T] = {
	def encode = (:T*) => T*				# Takes a T sequence and produces a T sequence
	def decode = (:T*) => T*
}

# Map signature: (:T*, :(T) => V) => V*
def Caeser = (shft: Char) Cipher[Char] {
	def encode = .map (+ shft)				# True "varible-less" functions
	def decode = .map (- shft)				# They inferentially meet the Cipher requirements
}

def test = (log: Logger) {					# Can the '{' depack the arg tuple ??
	log << ("{} {} +".fmt(3, 4) .parse .eval)
	log << ("{} {} + {} *".fmt(3, 4, 5) .parse .eval)
}

def arrayTest = (nums: Int*) {
	let arr = [1, 2, 3, 4, 5] ++ nums
	println("The first element is {}", arr(0))
}

!#
This approach seeks to unify lambdas and named functions under one syntax by making the args a tuple
This might have some problems with type metaprogramming in the future
!#