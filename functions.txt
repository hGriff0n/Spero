## TODO:
Settle on function signature syntax
Work on lambda arg syntax (parsing question)
Lazy vs strict function evaluation
Settle on argument syntax
##

# No-arg functions
def foo = () "Hello"		# This is how you define a no-arg function (parsing may be tricky to resolve)
def foo = () {			# The reasoning and semantics need a bit of work (but that should be rolled into the lambda work)
	let person = "Enter your name: {}".std:io:getln			# Here's another problem with indexing
	"Hello {person}!".fmt
}

using tst = foo			# This is how a no-arg function has to be re-"assigned"
let add = +			# Normal reassignment is equivalent to calling `+` with no arguments (ie. currying)
using add = +			# Operator syntax rules do not apply to add (it's the name, not the implementation


# Lambda functions
let sortfn = (a, b) { a < b }	# This works for any number of lines
let sortfn = (a, b) a < b	# I want one that works for one liners
let sortfn = (a, b) -> a < b	# That I can also extend to function signatures
let sortfn = (a, b) => a < b


# Function Signatures
def foo = (Int) String		# Mirrors the declaration syntax
def foo = (Int) => String	# The current syntax
def foo = (Int) -> String	# This may be delving into the metaprogramming territory


# Testing out contracts
let factorial = (:Number) .match {
	x => 1 .if x < 2		## This may require some creative grammar rules
	n => n * factorial(n - 1)
}


# Testing out parametric stuff


# Testing out infix function def syntax (match/generic syntax is uncertain at this point)
data Option[T] = Some(T) | None
# Keyword is necessary because Some and None aren't types, but constructors

# An function that doesn't follow variable name rules is automatically infix

# Scala style definitions (no ',' to separate args)
def >>= = (opt f) match opt {		# What if 'opt' becomes a context ???
	Some(val) => Some(f(val))
	None => None
}

# Current syntax
let >>= = (opt, f) .match {
	Some(val), f => Some(f(val))
	None, _ => None
}

Some(3) >>= add(5)			# operators are infix by default (no '.' needed)
>>=(None, add(4))			# what if .>>= allowed this instead ???
Some(3) add(5) ..>>=			# what if '..' turned a function into postfix


# Argument context and contract
def foo = (mut x: Int) {
	x = x + 1
}

# Function pattern matching
def take[T] = (:Size, :T*) .match {
	(0, _) = Nil
	(_, Nil) = Nil
	(n, x:xs) = x : take(n - 1, xs)
}

let add = (x, y) .match {
	0, y  => y
	suc(x), y => suc(add(x, y))
}

let fibonacci = (:Number) .match {
	0 => 1
	1 => 1
	n => fibonacci(n - 1) + fibonacci(n - 2)
}

##
Dot flipping ('.' operator)
Non-operator functions can be used in an infix manner by appending their name with a '.'
	Operators are implicitly infix, though they can used as normal functions, ie with `()`
	If an operator is "dot-flipped", then its precedence is "upgraded" to that of a function (so "5 * 3 .+ 3" equals 30)		<- Not very experimental at the moment
If a function only takes one argument, dot flipping allows postfix calling (similar to Haskell ./$ operator)
If a function takes 2+ arguments, dot flipping puts the "calling" value as the first argument
	Attempting to match the position would be unfeasible (ie. f(Int, Int) ??)
Class methods are implemented through dot-flipping ("3.abs" => (Int.abs)(3))
	Class (non-static) methods implicitly get a "self" member when defining

TODO: Determine if i should add a syntax to call postfix
TODO: Determine if dot-flipping should remove the "parentheses" requirement (for non-operators)
##

let factorial = (n) { n * n - 1 .factorial }
let factoiral = (n) { n * n - (1.factorial) }		# This is equivalent to the above
let factorial = (n) { n * (n - 1) .factorial }		# This is not (way too greedy)

# Variable arguments
def max[T] = (:T*) .sortWith(>)(0)			# A T* accepts a coninuous list of T if it is the last argument
max([3, 4, 5]) == max(3, 4, 5)				# Unless a view is passed in

