# Testing out simple function def syntax 
let add = (x, y) { x + y }	# New function syntax
let add = '+			# Functional support (very experimental)


# Testing out contracts (old syntax)
factorial (< 0) = 1
factorial n = n * factorial(n - 1)


# Testing out parametric stuff


# Testing out infix function def syntax (match/generic syntax is uncertain at this point)
data Option[T] = Some(T) | None
# Keyword is necessary because Some and None aren't types, but constructors

# An function that doesn't follow variable rules is automatically infix
# Rust style definitions
def >>=(opt: Option, f: Function) = {
	opt .match {		# `.<name>` turns the function/etc into infix
		Some(val) => Some(f(val))
		None => None
	}
}

# Scala style definitions (no ',' to separate args)
def >>= = (opt f) match opt {
	Some(val) => Some(f(val))
	None => None
}

# Current syntax
let >>= = (opt, f) => match opt {	# what if opt becomes a context
	Some(val) => Some(f val)	# this would turn f into an optional arg
	None => None
}

Some(3) >>= add(5)			# operators are infix by default (no '.' needed)
>>=(None, add(4))			# what if .>>= allowed this instead ???
Some(3) add(5) ..>>=			# what if '..' turned a function into postfix


# Argument context and contract
def foo = (mut x: Int) {
	x = x + 1
}

# Function casing (demonstrate with take, factorial, 
def take[T] = (:Size, :T*) .match {
	(0, _) = Nil
	(_, Nil) = Nil
	(n, x:xs) = x : take(n - 1, xs)
}

##
Dot flipping ('.' operator)
Non-operator functions can be used in an infix manner by appending their name with a '.'
If a function only takes one argument, dot flipping allows postfix calling (similar to Haskell ./$ operator)
Class methods are implemented through dot-flipping ("3.abs" => (Int.abs)(3))
	Class (non-static) methods implicitly get a "self" member when defining

TODO: Consider what '.+' means
TODO: Determine how to call operators in a prefix manner
TODO: Determine if i should add a syntax to call postfix
TODO: Determine what dot-flipping does on functions with >2 arguments (though this is what class methods do anyway)
##