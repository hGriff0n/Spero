8/15/2016 -
Okay I'm going to be starting a little devblog that explores my reasoning behind several design choices in, and the process of developing, Spero. Today's a rather good day to start such a blog, cause I'm currently in the middle of one of the more prescent syntactical decisions of the lanugage; the intersection of dot-flipping and indexing. As a little primer, dot-flipping is a syntactical construct that I sort of invented off the cuff while I was fleshing out naming schemes, particularly the operator/function division. What dot-flipping provided was a rather nice and simple way to enable infix functions where needed, a flexibility that I rather like in Haskell. Enabling functions to be called in a prefix and infix mode also trivialized the problem of universal call syntax and OOP invocation, just make sure that OOP methods take an implicit self parameter and the construction writes itself. However, at the time I had never given much thought as to how namespaces and the whole module system would work, and I had ended up taking it on faith that I would use "std.io" to refer to the standard io module. While it is rather easy to just declare a special rule for namespaces, this ambiguous parse brought me to the attention that several other idioms were invalid with dot-flipping. It was no longer possible to explicitly invoke the "abs" method from the "Int" type with "Int.abs(3)" as that would be translated to "abs(Int, 3)" which has no real meaning (atm). Simply, the problem was much more deep than something that could be solved with a simple if statement, it is something that needs a deep review of the language design and the relationship between the various components. In fact when I started typing this section I had thought I had solved the problem, but I ended up remembering a possible solution which threw the whole discussion out-of-whack for another day (or so). {TODO later}. Anyway lets see the three options.

1. Layered attempts. Since most all language constructs support dot-flipping and only a relative few support indexing, make it so that indexing support can be declared in language (like through a `.` function) and then as long as the function can be statically guaranteed to not throw an error on the inputs, the index operator will be chosen over the dot-flip. Otherwise, the dot-flip will be used to ensure correctness. This option I feel strikes a balance between simplicity of implementation and extendability. Being able to check the function statically will be a big challenge for implementing a compiler, but I am already planning on having compile time evaluation anyways, so it's a sacrifice I have to make. Meanwhile, I preserve the ability of being able to mix dot-flipping and indexing within one-object.

2. Either-or. The simplest of all the solution, this one just declares that if an object supports indexing, it automatically doesn't support dot-flipping. While I don't see many instances where such a duality of support is needed at the moment, I also can't see that there won't be a need in the future, especially depending on how metaprogramming gets implemented (types are always indexable).

3. The one I forgot. If you want something, sometimes you just have to go crazy in order to get it. This one takes the opposite step from 2 by declaring that everything is a dot-flip. Ordinarilly, this would mean that a lot of code suddenly becomes meaningless (ie. "Int.abs(3)"), but if you combine this proposal with parametrics, it suddenly becomes a lot more possible. If the parametric parameters are translated into implicit function arguments (of type Type), then the argument substitution performed by dot-flipping will be able to put any type (and other constructs) parameters into the correct slots of the called function implicitly, abstracting away the details of the implementation from the end user will still providing an extremely high degree of composability. How hard this will be to implement I won't know until I start to put together a more complete version of the parametric system.

8/18/2016 -
I'm writing this late at night on the day before I'm set to fly out after my internship at 7am, but I really want to try to get down my thoughts regarding the function syntax dillema I'm currently under. This whole thing started several weeks ago (though it really dates back to earlier design work) where I asked whether it was necessary to put the function signature on the left side of the assignment, to put it under the contract section. My reasoning is that creating a function is, and should be, little more than syntactical sugar for assigning a lambda. If this is the case, then, especially given Spero's emphasis on syntactical unity and simplicity, why not just remove the distinction altogether and bring the internal interaction to the forefront. This approach has several practical benefits aside from the nebulous "unity of thought"; it trimmed down the amount of "contractual" information, it enabled a rather nice syntax for writing "variable-less" functions (arguments have no names), and I just plain liked the approach. But no matter how much I liked it, I could never really get it to just "work". Initially, I had issues with writing one-liner "match"-functions, so I made the arguments into a simple tuple list. But then that solution brought the syntax to be indistinguishable from assignment in a closure, particularly with an empty tuple, so I added "special" syntax. Then it clashed with type declarations. On and on these problems arose, and I wasn't able to bring it to a satisfying conclusion. So I ended up just stopping working on the problem, taking a step back for a little while to see if I could gain some clarity. I don't know if I have or not, but today I looked into whether I could make use of the parametric syntax, to integrate the parameters into it. The compiler should be able to handle the added complexity well enough for the programmer's use and it doesn't introduce any additional errors (yet). Additionally it serves to unify a further element of the language, something that the old attempted syntax didn't do. My only thought know is do I switch over or not and, if yes, do I keep the '()' for calling functions?

8/21/2016 -
Syntax highlighting is one of the most important things you can add do your language development process, seriously. Up to now I was just working with pen and paper, even notepad, to develop the syntax of Spero, but this process has a fundamental problem I've found. {What is the problem, exactly?}. Since I spent the time working on vs-spero, modifying Scala's vs extension with my custom syntax, I've almost completely come around on the viability of the alternate syntax (the lambda/function merge). It doesn't look as bad, as out of place highlighted, than it does in a dull and smudgy grey.

Now the process of actually developing the extension was absolute hell. There is no documentation out there for how vs code syntax highlighting works, how thing X gets colored blue while thing Y gets colored yellow. But you can't even find basic stuff online, the only resources from microsoft are on how to develop language SERVERS, not a quick, down and dirty, syntax highlighter. The natural consequence of this is that I had to modify an existing extension to get what I wanted. But while this worked rather well, there are some annoying artefacts that I've had to accept. Some capabilities I don't need, some highlighting I don't want that I can't remove or change cause doing so fundamentally breaks the engine.

8/16/2016 - Design history and influences ???
	Haskell, Rust, Scala, C++