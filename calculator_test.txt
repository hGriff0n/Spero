## This program snippet is for testing whether to put the arg list to the left (the contracts) or the right (the expression) of the assignment
## TODO: My thoughts on both syntaxes

## Starting with the current syntax
module Calculator

## Currently I'm using * to represent an array/array_view/multiple arguments as a shorthand
## Everything to do with collections hasn't been considered yet
def main(args: String*) = while true {
	let line = std.io.getln
	let res = parse(line) .eval		## Normally this would be "eval(parse(line))". However, if you generalize the '.' rules for ucs, you can get a very haskell-esque syntax
	std.io.println("= {res}")
}

type Tree[T] = Leaf(T) | Branch(Tree, Tree)

def parse(cmd: String) = {
	cmd.groupWhile(isDigit)			## Right now I'm just assuming that you can pass in the function without specifying how arguments are handled
	   .filter(isInt)			## Scala uses a _ to specify the "whatever" case, which would turn these functions into _.isDigit or Leaf(_)
	   .map(Leaf)				## I don't know if I'll need to enforce creating a lambda to use a function in these std functions though
	   .reduce(Branch)
}

def eval(ast: Tree[Int]) = match ast {
	Leaf(val) => val
	Branch(l, r) => eval(l) + eval(r)	## Due to my hastiness, our calculator only supports addition
}

###################################################

###################################################

## Now with the new syntax. In order to make this work similarly to the current syntax, I have made it so that the argument list is a value
## Inside of the function body (specificaly a tuple). I need to find a better explanation of this (You could almost do this without variables)
def main = loop {				## Look into whether having a loop construct (ala Rust) would work well with this language
	let line = std.io.getln			## Cmd-line args would be gotten through std.env.getargs (ala Rust/Haskell)
	let res = parse(line) .eval
	std.io.println("= {res}")		## I just realize I have a problem with indexing and 'dot-flipping'
}

## Haskell-esque chaining
def main = std:io:println("= {}", std:io:getln .parse .eval) .loop	## The chaining of dot-flips (plus a keyword dot)

def parse = (String).groupWhile(isDigit)	## The "args as value" paradigm still needs a bit of work
		    .filter(isInt)		## One of the areas is in singleton tuples
		    .map(Leaf)			## It's much nicer to be able to work on the value without dereferencing
		    .reduce(Branch)		## Most collection methods, should be able to work on tuples (with type checking cause tuples are heterogeneous)
							## By this I mean that the called method should be callable for every type in the tuple

def eval = (Tree[Int]) .match {			## You don't have to provide arg names in this syntax
	Leaf(val) => val			## Note that match is a keyword, not a function
	Branch(l, r) => eval(l) + eval(r)	## However, there's no reason I can't enable the '.' syntax on it
}

def add = (x: Nat, y: Nat) .match {		## Match would know how many items are in the tuple already
	x, Zero => x				## So it can check about casing validity, etc.
	x, Suc(_y) => add(x, _y) .Suc		## The only question is whether a comma can occur naturally on the left side of the case
}						## I could always add in a keyword (on) if that's the case


## I really like the new syntax, especially with it's possibility for functional programming
## However, I really need to nail down tuple dereferencing rules before I can accept it
## I should also look into whether I can allow both, though I want the language to have one way to do basics

#! Problem 2 with the new syntax
What's the difference between "(x)" as an argument and "(x)" as an expression and "(x)" as a tuple constructor
	I could replace the expression with "{x}" with relative ease
	As mentioned earlier, arguments are just tuples with some special considerations and abilities
!#

## Should (Int, Float) be restricted to arguments, or can I use them in meta-programming
	## Restrict for now, but the possibility is very intriguing
	## If tuple functions (ie. map) can work on compile time, and you can create functions that work on types, the metaprogramming will be strong and intuitive


load_module("never-load") .if true		## Dot-flipping should be extendable to expression keywords