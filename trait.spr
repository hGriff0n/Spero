let Showable = {
    def toStr :: () => String
}

@annotate("This is a class")
let Numeric = {
    def + :: (Numeric) -> Numeric
    def - = .neg + self
}

# BigInt is showable and numeric
def BigInt = (num :: String) {
    use {Numeric, Showable}                 # Same syntax as the module mechanism (semantics slightly different)

    def toStr = num
    def + = (val :: Numeric) -> BigInt(num + val.toStr)
}

##
This is also valid
def BigInt = (num: String) Numeric{         Sugar for "use Numeric"
    use Showable

    def toStr = num
    def + = (val: Numeric) ->
        BigInt(num + val.toStr)
}
##