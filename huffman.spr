mod huffman
use std.{io, iter}.*

def Huffman[probs: Float*] = {
    # The tree gets constructed automatically since it accepts a Float*
    let decoder = HuffmanHelper(probs) {
        type Reducer = Unk(String, String) | Knw(String) {

		let mesg = .match {
			Knw(s) => s
			_ => Error{ "Could not decode the message" }
		}

        def help[: String] =
            .reduce(Collect(""), (char, collector) => {
                let msg = collector .match {
                    Unk(s, t) => (s, t + char)
                    Knw(s) => (s, char)
                }

                if (tree.hasLeafAt(msg._2))
                    Knw(msg._1 + tree.getLeafAt(msg._2))
                else
                    Unk(msg._1, msg._2)
            }) .mesg
    }

    let encoder = HuffmanHelper(probs) {
        let help[: String] = .fmap(tree.getCodeFor)            # Doesn't consider the 127 thing
    }

    static writeTo[f: File, data: String] = f.writeAll(data)
    static readFrom[: File] = .readAll

    def encode[in: File, out: File] =
        out .writeTo(encoder.help(in .readFrom))

    def decode[in: File, out: File] =
        out .writeTo(decoder.help(in .readFrom))
}

let HuffmanHelper[tree: HuffmanTree] = {
    def help[msg: String] => String
    def setTree[...] = { ... }
}

let HuffmanTree[probs: Float*] = {
    let HuffmanNode = {						# Needs more work on interfaces and type implementations

    }
}