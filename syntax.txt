## TODO
Figure out how to resolve indexing and dot-flipping
Settle on mutability solution
Figure out how to access a tuple
##

# This is a single line comment

##
This is a multiline comment
##

# Assignment syntax
<context> <name> <contracts> = <scope>
	# I'm not sure about how multiple contracts will be handled

##
Context is always a keyword that describes how the rest of the expression gets treated
    Current Valid Context Keywords:
	let    <- introduce a new name binding of protected visibility
	def    <- introduce a new name binding of public visibility
	static <- introduce a new name binding of static visibility
	using  <- create a new alias in the current scope
	type   <- create a new ADT in the scope (constructors are in the expression)

    Possible Contexts:
        mut    <- mutable name binding
	data   <- replaces `type`

Name indicates the scoped binding that the statement will exist under
Some additional information about the binding can also be derived here
	variable  = [a-z_].*		<- first letter must be lowercase
	type      = [A-Z].*		<- first letter must be uppercase
	operator  = ^[variable|type]	<- anything else, automatic infix syntax

Contracts refine the binding information with additional rules for static matching
    Current Contracts: (Come up with defaults once I've settled on the list)
	type bindings	    =   :: T	<- syntax taken from haskell (extra character because I want programmers to use type inference, also allows for a single character in indexing)
	parametrics	    =   [T]

    Possible Contracts:
        mutabilitiy	    =   mut

Scope is the series of instructions that will be bound to the name
	Single-line scopes do not need the `{}`, but multiline scopes do
	TODO: IMPROVE explanation
##

# Some examples of assignment
let m = 3		# Variables are immutable by default
let t :: String = 3	# Error (type contract not maintained)
let m = "Hello"		# Variables can be "shadowed" by latter declarations

# Enabling mutability
let n = mut 3		# function
mut n = 3		# context
let n mut = 3		# contract
let n :: mut Int = 3	# type modifier, ala `const` (the mut "function" would just perform inference)


# Dot-flipping
"Hello".print		# Same as print("Hello"). Functions can be applied in-/post-fix by prepending a '.' to their name
"3 + 4 = {}".println(7) # Can be used with functions that take multiple arguments, the "calling" value is inserted as the first argument
			# This is how OOP is implemented internally, through an implicit "self" parameter


# Indexing
std:io:Writer		# module
Int:abs			# type
Int:push		# this will fail if called (don't fail necessarily for metaprogramming uses)

# Sequences/Views
let view = [1, 2, 3, 4, 5]	# Note that view is not an array (it has type T*)
let arr = view.asArray		# Array is instead a stdlib collection (of type Array[T])

##
Keywords:		<- The "flippable" keywords needs more explanation
    Keywords are divisible into two types, "flippable" and "normal". Flippable keywords are more similar syntax wise to functions than they are
	to normal keywords. However, in order to fully make these "functions" usable in language, it is necessary to add in some syntactical sugar
	to their use. Flippable keywords can be used in-line, dot-flipped, etc. just like a normal function. However, unlike a function, it is not
	required to use parentheses to wrap the keyword's "arguments", ...

    Flipable keywords:
	match
	if
	while

    Normal keywords:
	{Context keywords}
	mod
	use

    Uncertain:
	else
##

##
Default Operators:
	Equality   '=='
	Assignment '='
##