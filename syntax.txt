## TODO
Look into raw references and pointers
Look into contextual evaluation (see 'mut_testing.spqr' for more)
Figure out monads
Look into borrowing semantics
##

# This is a single line comment

##
This is a multiline comment
##

# Assignment syntax
<context> <name> <contracts> = <scope>
	# I'm not sure about how multiple contracts will be handled

##
Context is always a keyword that describes how the rest of the expression gets treated
    Current Valid Context Keywords:
	let	<- introduce a new name binding of protected visibility
	def	<- introduce a new name binding of public visibility
	static	<- introduce a new name binding of static duration
	using 	<- create a new alias in the current scope

    Possibly Deprecated
	adt	<- create a new ADT in the scope (constructors are in the expression)

Name indicates the scoped binding that the statement will exist under
Some additional information about the binding can also be derived here
	variable  = [a-z_].*		<- first letter must be lowercase
	type      = [A-Z].*		<- first letter must be uppercase
	operator  = ^[variable|type]	<- anything else, automatic infix syntax

Contracts refine the binding information with additional rules for static matching
    Current Contracts: (Come up with defaults once I've settled on the list)
	type bindings	    =   :: T	<- syntax taken from haskell (allows for a single ':' in indexing)
	generics	    =   [T]

Scope is the series of instructions that will be bound to the name
	Single-line scopes do not need the `{}`, but multiline scopes do
	TODO: Improve explanations

Note that there is no special keyword/syntax for creating functions, everything is instead a lambda
	There are three syntaxes for lambda functions (TODO: Improve explanations)
		1. Multiline - (Params...) -> Ret { ... }			# The '-> Ret' is optional (compiler can infer it)
		2. Single-line - (Params...) -> ...
		3. Forwarding - . ...
			This relies on dot-forwarding to enable very terse function compositions that take full advantage of type inference
##

# Some examples of assignment
let m = 3		# Variables are immutable by default
let t :: String = 3	# Error (type contract not maintained)
let m = "Hello"		# Variables can be "shadowed" by latter declarations


# Dot-flipping
"Hello".print		# Same as print("Hello"). Functions can be applied in-/post-fix by prepending a '.' to their name
"3 + 4 = {}".println(7) # Can be used with functions that take multiple arguments, the "calling" value is inserted as the first argument
			# This is how OOP is implemented internally, through an implicit "self" parameter


# Indexing
std:io:Writer		# module
Int:abs			# type
Int:push		# this will fail if called


# Querying
Int?push		# Test if Int:push is valid
push?Int		# Test if push takes an Int
?push			# Test if push is defined in the current scope ???


# Sequences/Views
let view = [1, 2, 3, 4, 5]	# Note that view is not an array (it has type T*)
let arr = view.asArray		# Array is instead a stdlib collection (of type Array[T])


##
Keywords:		<- The "flippable" keywords needs more explanation
    Keywords are divisible into two types, "flippable" and "normal". Flippable keywords are more similar syntax wise to functions than they are
	to normal keywords. However, in order to fully make these "functions" usable in language, it is necessary to add in some syntactical sugar
	to their use. Flippable keywords can be used in-line, dot-flipped, etc. just like a normal function. However, unlike a function, it is not
	required to use parentheses to wrap the keyword's "arguments", ...

    Flipable keywords:
	match
	if
	while

    Normal keywords:
	{Context keywords}
	mod
	use
	self		<- refers to the current scope/object instance

    Uncertain:
	else
##

##
Default Operators:
	Equality   '=='
	Assignment '='
	Inspection '?'
##

# Mutability
Mutability is part of the type system (ala C++ 'const')
	`Int` is immutable, `mut Int` is mutable
	`mut` must be bound to a type				<- I may end up changing this in the future
		can't write "def foo = (f :: mut) -> {}"
		can write "def foo = (f) -> { let f = mut f ... }
The `mut` keyword/function helps for type inference
	It may be possible to implement mut in the language (depending on how inference works)
		def mut[T] :: (T) -> mut T = .			# Possibly inefficient (copying)
		def mut[T] :: (mut T) -> mut T = .		# Possibly inefficient (copying)
			I don't know if I'd allow this (overloading based on mutability)
'mutable' annotation
	The mutable annotation can be applied in the context of type definitions to conditionally enable/disable code
		'@mutable' has two modes of operation, a enable/disable and a query mode
		The enable/disable mode applies to the next segment of code		<- General use case
			This segment will only be available on a mutable instance of the object
			A compiler error is produced if the call is attempted (the method technically "exists" for resolution)
		The query mode applies in the context of boolean operations
			This can enable conditional method behavior based on mutability of the object
Compiler Behavior
	A warning is produced if any "state" members are shadowed (especially for mutability)
	An error is produced if any type members are modified in a method without the 'mutable' annotation
		This would mean that the annotation is possibly unnecessary, but I'm going to keep it for now
			Possibly more readable to have the explicit knowledge that the method only exists in certain conditions
	Type members must be mutable in the definition if any mutable operations are to be performed on them
		ie. Immutability is innate to type members, mutability is dependent on the surrounding instance
		If the object is immutable, modification of any non-static members is disallowed	<- might change
Assignment and Arguments
	Mutability is not kept in shadowing assignment, unless `mut` is used
	The full rules for mutability and shadowing/assignment/function interaction are below

	OPERATION		DEFAULT BEHAVIOR
	RHS => LHS	(Shadow RHS)
	T => T			Reuse | Allocate			<- Reuse iff there are no aliases
	mut T => T		Reuse					^- Otherwise allocate
	T => mut T		Copy (Can reuse if mut is unnecessary)
	mut T => mut T		Reuse | Allocate
	V => T			Allocate

	LHS = RHS	(Assign RHS to LHS)
	V = T			Alias					<- Aliasing maintains a reference to the object
	V = mut T		Copy (Can alias if mut is unnecessary)	^- The value is kept around if there are aliases to it
	T = V			Allocate				^- Even if it is later shadowed
	
	Call => Def
	f(T) => f(T)		Reuse
	f(mut T) => f(T)	Reuse
	f(T) => f(mut T)	Copy (Can reuse if mut is unnecessary)
	f(mut T) => f(mut T)	Copy (Can reuse if mut is unnecessary) 		<- Reuse would break the external semantics

# Aliasing
Aliasing acts as a simple form of variables, with minor syntactical overhead
	By default, an alias can be implemented as a simple textual replacement of the "source" variable
	If the source variable is shadowed, then the alias refers to the variable at the point of aliasing
		This will disable some optimizations due to the maintained reference (see mutability section)

		let x = 3
		using three = x
		let x = 5
		"{}".println(three)		# prints '3'

# Tuples
let a = (1, 3)
let (b, c) = a			# Decomposing a tuple

a.max				# Calling a multi-arg function with a dot-flipped tuple
a._0				# Access the first tuple argument (compiler generated)

# Annotation Demo (actual implementation won't be followed, but this is a decent idea of what I want)

@force(parens)							# This annotation is applied to the next statement (others may have module/file level application)
let splitable_constructors = {					# So this whole block requires parentheses to call a function
	let is_splitable = type_list.map(:split)
	let constructors = type_list.map(:new)

	(constructors, is_splitable).zip.filter(.match {	# Dot-flipping doesn't need parentheses (special-casing, though)
		_, splitable -> splitable.Boolean
	})
}
