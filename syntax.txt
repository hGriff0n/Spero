## TODO
Delve into mutability inference
Add a way to access the current scope
Figure out how to access a tuple
Figure out monads
##

# Mutability
Mutability is part of the type system (ala C++ 'const')
	`Int` is immutable
	`mut Int` is mutable
	`mut` must be bound to a type				<- I may end up changing this in the future
		can't write "def foo = (f :: mut) -> {}"
		can write "def foo = (f) -> { let f = mut f ... }
The `mut` keyword/function helps for type inference
	It may be possible to implement mut in the language (depending on how inference works)
		def mut[T] :: (T) -> mut T = .
Mutability is not maintained in assignment (TODO: I'm not sure about how this'll work at all)
	let f = mut 3		# mut Int
	let r = f		# Int (copy)
	let f = f		# Int (reuse)
'mutable' annotation can be applied to type methods
	Produces a compiler error if trying to call on an immutable instance
	A warning is produced if any "state" members are shadowed (especially for mutability)
	An error is produced if any type members are modified in a method without the 'mutable' annotation
		This is true even if the type members are mutable themselves

# This is a single line comment

##
This is a multiline comment
##

# Assignment syntax
<context> <name> <contracts> = <scope>
	# I'm not sure about how multiple contracts will be handled

##
Context is always a keyword that describes how the rest of the expression gets treated
    Current Valid Context Keywords:
	let	<- introduce a new name binding of protected visibility
	def	<- introduce a new name binding of public visibility
	static	<- introduce a new name binding of static visibility
	using 	<- create a new alias in the current scope
	adt	<- create a new ADT in the scope (constructors are in the expression)

Name indicates the scoped binding that the statement will exist under
Some additional information about the binding can also be derived here
	variable  = [a-z_].*		<- first letter must be lowercase
	type      = [A-Z].*		<- first letter must be uppercase
	operator  = ^[variable|type]	<- anything else, automatic infix syntax

Contracts refine the binding information with additional rules for static matching
    Current Contracts: (Come up with defaults once I've settled on the list)
	type bindings	    =   :: T	<- syntax taken from haskell (allows for a single ':' in indexing)
	generics	    =   [T]

Scope is the series of instructions that will be bound to the name
	Single-line scopes do not need the `{}`, but multiline scopes do
	TODO: Improve explanations

Note that there is no special keyword/syntax for creating functions, everything is instead a lambda
	There are three syntaxes for lambda functions (TODO: Improve explanations)
		1. Multiline - (Params...) -> Ret { ... }			# The '-> Ret' is optional (compiler can infer it)
		2. Single-line - (Params...) -> ...
		3. Forwarding - . ...
			This relies on dot-forwarding to enable very terse function compositions that take full advantage of type inference
##

# Some examples of assignment
let m = 3		# Variables are immutable by default
let t :: String = 3	# Error (type contract not maintained)
let m = "Hello"		# Variables can be "shadowed" by latter declarations


# Dot-flipping
"Hello".print		# Same as print("Hello"). Functions can be applied in-/post-fix by prepending a '.' to their name
"3 + 4 = {}".println(7) # Can be used with functions that take multiple arguments, the "calling" value is inserted as the first argument
			# This is how OOP is implemented internally, through an implicit "self" parameter


# Indexing
std:io:Writer		# module
Int:abs			# type
Int:push		# this will fail if called


# Querying
Int?push		# Test if Int:push is valid
push?Int		# Test if push takes an Int
?push			# Test if push is defined in the current scope ???


# Sequences/Views
let view = [1, 2, 3, 4, 5]	# Note that view is not an array (it has type T*)
let arr = view.asArray		# Array is instead a stdlib collection (of type Array[T])


##
Keywords:		<- The "flippable" keywords needs more explanation
    Keywords are divisible into two types, "flippable" and "normal". Flippable keywords are more similar syntax wise to functions than they are
	to normal keywords. However, in order to fully make these "functions" usable in language, it is necessary to add in some syntactical sugar
	to their use. Flippable keywords can be used in-line, dot-flipped, etc. just like a normal function. However, unlike a function, it is not
	required to use parentheses to wrap the keyword's "arguments", ...

    Flipable keywords:
	match
	if
	while

    Normal keywords:
	{Context keywords}
	mod
	use

    Uncertain:
	else
##

##
Default Operators:
	Equality   '=='
	Assignment '='
	Inspection '?'
##

# Annotation Demo (actual implementation won't be followed, but this is a decent idea of what I want)

@force(parens)							# Annotations are applied to the next statement
let splitable_constructors = {					# So this whole block requires parentheses to call a function
	let is_splitable = type_list.map(:split)
	let constructors = type_list.map(:new)

	(constructors, is_splitable).zip.filter(.match {	# Dot-flipping doesn't need parentheses (special-casing, though)
		_, splitable -> splitable.Boolean
	})
}
