# This is a single line comment

##
This is a multiline comment
##

# Assignment syntax
<context> <name> <contracts> = <expression>
	# I'm not sure about how multiple contracts will be handled

##
Context is always a keyword that describes how the rest of the expression gets treated
    Current Valid Context Keywords:
	let    <- introduce a new name binding of protected visibility
	def    <- introduce a new name binding of public visibility
	static <- introduce a new name binding of static visibility
	using  <- create a new alias in the current scope
	type   <- create a new ADT in the scope (constructors are in the expression)
	mod    <- indicate the module for the current file (file section?)
	use    <- import from another module

    Possible Contexts:
        mut    <- mutable name binding

Name indicates the scoped binding that the statement will exist under
Some additional information about the binding can also be derived here
	variable  = [a-z].*		<- first letter must be lowercase
	type      = [A-Z].*		<- first letter must be uppercase
	operator  = ^[variable|type]	<- anything else, automatic infix syntax

Contracts refine the binding information with additional rules for static matching
    Current Contracts: (Come up with defaults once I've settled on the list)
	type bindings	    =   :T
	parametrics	    =   [T]

    Possible Contracts:
        mutabilitiy	    =   mut

Operators
	Assignment '='		<- can't write "let =(x) = ..."
	Subtyping  ':'		<- can't write "let :(x) = ..."
	Equality   '=='

The expression can be any valid construct in the language
Scopes (multiple expressions) can possibly be encapsulated by surrounding with '{}'
	I'm not sure about whether whitespace should format scopes or not
##

# Some examples of assignment
let m = 3		# Variables are immutable by default
let t :String = 3	# Error (type contract not maintained)
let m = "Hello"		# Variables can be "shadowed" by latter declarations

# Enabling mutability
let n = mut 3		# Special 'mut' function
mut n = 3		# I could move 'mut' into the context
let n mut = 3		# Or put it into the contract


# Dot-flipping
"Hello".print		# Same as print("Hello"). Functions can be applied in-/post-fix by prepending a '.' to their name
"3 + 4 = {}".println(7) # Can be used with functions that take multiple arguments, the "calling" value is inserted as the first argument
			# This is how OOP is implemented internally, through an implicit "self" parameter

# Indexing 		<- The interaction of indexing and dot-flipping is a current sticking point of the language
std.io.println
std:io:println

Int.abs			# You can test for an existence of a function rather simply
Int:abs

##
Keywords:		<- The "flippable" keywords needs more explanation
    Keywords are divisible into two types, "flippable" and "normal". Flippable keywords are more similar syntax wise to functions than they are
	to normal keywords. However, in order to fully make these "functions" usable in language, it is necessary to add in some syntactical sugar
	to their use. Flippable keywords can be used in-line, dot-flipped, etc. just like a normal function. However, unlike a function, it is not
	required to use parentheses to wrap the keyword's "arguments", ...

    Flipable keywords:
	match
	if
	while

    Normal keywords:
	{Context keywords}

    Uncertain keywords:
	else
##