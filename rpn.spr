##
A little test program to help work out the vs-spero extension and for settling the function syntax
The test program is primarily a basic RPN calculator with some non-rpn functions
##

mod rpn
use std:{io, str}:*

def main = getln .parse .println("= {}")

type Stack[T] = Empty | Cons(T, Stack) {
	def toStr = self .match {
		Cons(i, Empty) => i.toStr
		_              => "nil"
	}
}

let parse = (:String)
	.groupWhile(isDigit)
	.removeIf(isSpace)
	.reduce(Empty, (a, b) .match {
		Cons(r, Cons(l, _s)), "+" => Cons(l + r, _s)
		Cons(r, Cons(l, _s)), "-" => Cons(l - r, _s)
		Cons(r, Cons(l, _s)), "/" => Cons(l / r, _s)
		Cons(r, Cons(l, _s)), "*" => Cons(l * r, _s)
		Cons(l, _s), "~"          => Cons(-l, _s)
		s, _                      => Cons(_.toInt, s) 
	})._1									# A minor problem with the current proposal (the '_1')

# Comment for consistency with `rpn_v2.spr`
let eval = (:Stack[Int]) .match {
	Cons(i, Empty) => i.toStr
	_              => "nil"
}

let Cipher[T] = {
	def encode = (T*) => T*					# `encode` takes a T sequence and produces a T sequence
	def decode = (T*) => T*
}

# map[T, V] = (T*, (T) => V) => V*
def Caeser = (shft: Char) {
	use Cipher[Char]						# Inheritance/Interfaces

	def encode = .map (+ shft)				# True "varible-less" functions
	def decode = .map (- shft)				# They inferentially meet the Cipher requirements
}

def test = (log: Logger) {					# Can the '{' unpack the arg tuple ??
	log << ("{} {} +".fmt(3, 4) .parse .eval)
	log << ("{} {} + {} *".fmt(3, 4, 5) .parse .eval)
}

def arrayTest = (nums: Int*) {
	let view = [1, 2, 3, 4, 5] ++ nums		# The language intrinsic is a view (or sequence)
	let arr = nums.toArray					# Array is a stdlib feature

	println("The first element is {}", arr(0))
}

def sortTest[T] = (view: T*) {
	let (a, b) = (3, 4)

	view.sort((a, b) {
		a < b								 # Assume there's a more complex calculation here
	}).toStr.println

}

def split = (s: String, i: Int) =>		# The `=>` is an alternate way to start the function body ??
	s.zipWith(index)
	 .groupWhile(< i)

##
Problems:
	Large problems with writing variable-less functions
		Arguments are in a tuple => operations are on tuples and return type is a tuple
		Neither are desired in the abstract (need a simple way to justify decomposing)
	Possible issues with type-level metaprogramming
	Small issue with syntax for lambda functions
		Is `(a, b)` a tuple with the values of a and b or an arugment tuple of generic type ???
##