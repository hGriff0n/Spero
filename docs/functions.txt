NOTE: Some of the assertions, especially in regard to overloading and inference, are entirely theoretical at this point in time. I have no idea of how difficult it'll be to implement them

Functions
  Grammar:
    <tuple> -> <type>? <scope>
    <tuple> -> mut? .?<statement>
    mut? .<statement>

  Type Signature:
    (Params...) -> Ret			# NOTE: Shorthand for the below
    Function[(Params...), Ret]

  Defining a function with the same name creates an overload
    The original function must be in the same scoping level as the second function
      Otherwise scoped shadowing occurs where the second function "replaces" the original
    Functions can be overloaded on the basis of paramter and return types
      It is permissable for a compiler error to be produced if an overload matches a previous declaration
      Otherwise, any errors should be discoverable within the overload resolution process

  OOP handling
    Non-static methods declared within a type body have an implicit "self" parameter as the first argument
      NOTE: OOP functions implicitly handle dot-flipping as a result
    Member variables may be accessed without indexing this 'self' body, but can be shadowed
      NOTE: It is a compiler error to shadow the 'self' variable within a method

  Dot-Forwarding
    Dot-forwarding indicates that the function's arguments should be directly passed to the function body
      Roughly analagous to an implicit cut-and-past with a dot-flipping call
        NOTE: Actual implementation probably shouldn't follow this pattern

    Any function body that begins with a '.' (or 'mut .') is subject to dot-forwarding
      If no argument tuple for the function is provided, one is inferred from the body
        An overload set may be created based on the body of the function
          This is if a function in the body chain is itself an overload
	  The overload set is the maximal set that produces a valid typing given the function body
      If an argument tuple is provided, argument names may be dropped for a tacit-style
        This tuple mainly reserves to restrict the overload set to "coherent" typings

Function Calling
  Grammar:
    <value><tuple>?
    <value> <op> <value>		# NOTE: look at <> for operator currying
    <value>.<fncall>			# Dot-flipping syntax

  Omitting Parentheses:
    Function parentheses can be omitted when a no-arg function is called
      Renaming a no-arg function presents a bit of a syntactical challenge:
	One option is to create a forwarding lambda, ala "let <name> = .<fn>"
	Another option is to disable no-paren calling, ala "@disable(no_paren)let <name> = <fn>"

  Function evaluation within Spero is an eager process
    Lazy evaluation can be mimiced with streams/generators/ranges/captures/etc.

  Dot-Flipping
    Dot-flipping allows functions to be called in an "infix" fashion by prepending a '.'
      The preceding atom is considered to be the first argument to the function (ala. OOP)
        Note: "n - 1.factorial" translates to "n - {1.factorial}" not "{n - 1}.factorial"
      When invoked, the atom is inserted before the other arguments in the tuple
        Note: "T.fn(...)" is equivalent to "fn(T, ...)
        Experimental: If the "caller" argument is a n-ary tuple, tuple application may apply
      When used with operators, dot-flipping only serves to upgrade the precedence to that of functions
        NOTE: The requirement for parenthesis may be dropped with operators in the future

  Var-arg functions
    If the final argument to a function has the type T.., then 0+ T's can be passed at the end of the function
      NOTE: The arguments are implicitly converted to an 'Array[T, n]' container/view

  Overload Resolution
    There are 5 modes of overload matching: Exact, Polymorphic, Generic, Implicit, None (NOTE: In rank order)
      Exact       <- Exact type match, 'Arg == Param'
        NOTE: Var-arg matches are considered to be at the "exact" level
      Polymoprhic <- Subtype relationship, 'Arg :: Param'
      Generic     <- Generic matching, '[Param]'			# NOTE: See 'types.txt' for more
      None        <- Failure state
      Implicit    <- Construct from the arg, 'Param:new(Arg)'
        Only one level of non-explicit constructors are considered for Implicit matching
        Experimental: The entire argument set may be considered for overloads with only 1 parameter

    TODO: Need to add in language to enable partial-application resolution

    The resolution process goes similarly to this
      Choose all functions of name f into the overload set
        If there are any arguments, add a small weight to all functions T:f where T = type(f.params[0])
      From the overload set, choose all functions, f, so that
        The match on f.return is no worse than any other overload	# NOTE: What if I or'd these
        The worst match on f.params is no worse than the match on any other overload
      If more than one such function exists in the overload set, reduce as follows
	f is a member function (ie. has the 'T:f' weight)
        The mutability match on f.params is no worse than any other overload
      A dispatch (overload resolution) error will occur if one of the following applies
	No function was selected by the overload process (no overload exists)
	2 or more functions were selected by the overload process (multiple overloads exist)
	2 or more construction paths for an Implicit match exists (can be viewed as the previous case)

Partial Application
  A partial application is a function with some arguments bound from a prior call site
    Note: All unbound arguments are at the end of the parameter list

  A function call reduces to a partial application iff
    Overload resolution fails because of a too small input
    A possibly valid overload may exist, given the current arguments
    The resulting function is stored/used (variable/argument/return)

  The partially applied function maintains the same overload set as the parent function
    This is minus all overloads that would be invalid given the pre-existing overload set
    This inheritance is static to the time that the function was created
      ie. Overloading the function afterward should not affect partial application

  Positional Currying of Operators
    Binary operators can have different semantics depending on if a value is bound to the left or the right
    Binding a value to the lhs is trivial to perform ("<value> <op>")
    Binding a value to the rhs requires a workaround with dot-forwarding (".<op> <value>")
      NOTE: Currently, parenthesis are not needed for currying operators but are needed for indexing

  Experimental: Can be disabled through the '@disable(curry)' annotation 	# Change name?

Experimental Ideas:
  Define '+' for functions, so "f + g" creates a function 'h', "h(...) = f(...) + g(...)"

TODO:
  Add in better language for partial application resolution
  Improve wording and understanding of var-arg recognition in overload resolution
  Add in language to account for 'mutable' methods