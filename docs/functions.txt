NOTE: Some of the assertions, especially in regard to overloading and inference, are entirely theoretical at this point. I have no idea how to implement them

Functions
  Grammar:
    <tuple> -> <type>? <scope>
    <tuple> -> mut? .?<statement>
    mut? .<statement>

  Type Signature:
    (Params...) -> Ret			# NOTE: Shorthand for the below
    Function[(Params...), Ret]

  Defining a function with the same name creates an overload
    The original function must be in the same scoping level as the second function
      Otherwise under scoping rules, the second function "replaces" the original
    Functions can be overloaded on the basis of paramter and return types
      A compiler error is produced if an overload exactly matches a previous decl
      Otherwise, any errors are discovered within the overload resolution process

  OOP handling
    Non-static methods declared within a type body have an implicit "self" first parameter
      Note: OOP functions implicitly handle dot-flipping as a result
        Except not really, given ad-hoc polymorphism (interfaces)
    Member variable access implicitly indexes this 'self' body, unless shadowed
      Note: Explicitly indexing self/super will always work for access
      Note: It is a compiler error to shadow the 'self'/'super' variables

  Dot-Forwarding
    Dot-forwarding indicates that the function's arguments should be directly passed to the function body
      Roughly analagous to an implicit cut-and-past with a dot-flipping call
        NOTE: Actual implementation probably shouldn't follow this pattern

    Any function body that begins with a '.' (or 'mut .') is subject to dot-forwarding
      If no argument tuple for the function is provided, one is inferred from the body
        An overload set may be created based on the body of the function
	  The overload set is the maximal set of valid typings given for the body
      If an argument tuple is provided, argument names may be dropped (ie. Types only)
        This tuple mainly serves to restrict the overload set to "coherent" typings

Function Calling
  Grammar:
    <value><tuple>?
    <value> <op> <value>		# NOTE: look at <> for operator currying
    <value>.<fncall>			# Dot-flipping syntax

  Function evaluation within Spero is an eager process
    Lazy evaluation can be mimiced with streams/generators/ranges/captures/etc.
    When the function is evaluated can be moved by the compiler

  Dot-Flipping
    Dot-flipping allows functions to be called in an "infix" fashion
      The preceding atom is considered to be the first arguments to the function
        Note: "n - 1.factorial" => "n - {1.factorial}", not "{n - 1}.factorial"
      When invoked, the atom is inserted before the other arguments in the tuple
        ie. "T.fn(...)" is equivalent to "fn(T, ...)
        Experimental: If the "caller" is a n-ary tuple, tuple application applies
      When used with operators, dot-flipping upgrades to the level of functions
        Note: Dot-ops stil require parenthesis for the moment

  Omitting Parentheses:
    Function parentheses can be omitted when a no-arg function is called
      Renaming a no-arg function presents a bit of a syntactical challenge:
	One option is to create a forwarding lambda, ala "let <name> = .<fn>"
	Another option is to disable no-paren calling, ala "@disable(no_paren)let <name> = <fn>"
        A third is to use "importing" to rebind the name, ala "use <fn> as <name"

  Var-arg functions
    If a function's final argument has a view typing, it is "var-arg" parameter
      The function will accept 0+ T's being passed at the end
        This T's will be grouped into a Sequence[T] container/view (ie. 'Array[T, n]')

  Overload Resolution
    5 modes of overload matching: Exact, Polymorphic, Generic, Implicit, None
      Exact       <- Exact type match, 'Arg == Param'
        Note: Var-arg matches are considered to be at the "exact" level
      Polymoprhic <- Subtype relationship, 'Arg :: Param'
      Generic     <- Generic matching, '[Param]'
      None        <- Failure state
      Implicit    <- Construct from the arg, 'Param:new(Arg)'
        Only one level of non-explicit constructors are considered for Implicit matching
        Experimental: The entire argument set may be considered for overloads with only 1 parameter
      Note: These are given in the rank order used by the resolution algorithm

    TODO: Go over this entire resolution process and reword it
    The resolution process goes similarly to this
      Choose all functions of name f into the overload set
        If there are any arguments, add a small weight to all functions T:f where T = type(f.params[0])
      From the overload set, choose all functions, f, so that
        The match on f.return is no worse than any other overload	# NOTE: What if I or'd these
        The worst match on f.params is no worse than the match on any other overload
      If more than one such function exists in the overload set, reduce as follows
	f is a member function (ie. has the 'T:f' weight)
        The mutability match on f.params is no worse than any other overload
      A dispatch (overload resolution) error will occur if one of the following applies
	No function was selected by the overload process (no overload exists)
	2 or more functions were selected by the overload process (multiple overloads exist)
	2 or more construction paths for an Implicit match exists (can be viewed as the previous case)

Partial Application
  A partial application is a function with some arguments bound from a prior call site
    Note: All unbound arguments are at the end of the parameter list

  A function call reduces to a partial application iff
    Overload resolution fails because of too little arguments
    A possibly valid overload may exist, given the current arguments
    The resulting function is stored/used (variable/argument/return)

  The partial function maintains the same overload set as the parent function
    Minus all overloads that would be invalid given the bound arguments
    This inheritance is static to the time that the function was created
      ie. Overloading the function afterward should not affect partial application

  Positional Currying of Operators
    Binary operators can have different semantics depending on if a value is bound to the left or the right
    Binding a value to the lhs is trivial to perform ("<value> <op>")
    Binding a value to the rhs requires a workaround with dot-forwarding (".<op> <value>")
      Note: Currently, parenthesis are not needed for currying operators but are needed for indexing
        Note: This contradicts earlier statements

  TODO: Need to add in language to enable partial-application resolution

  Experimental: Can be disabled through the '@disable(curry)' annotation 	# Change name?

Experimental Ideas:
  Define '+' for functions, so "f + g" creates a function 'h', "h(...) = f(...) + g(...)"

TODO:
  Add in better language for partial application resolution
  Improve wording and understanding of var-arg recognition in overload resolution
  Add in language to account for 'mutable' methods