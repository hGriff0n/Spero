TODO: Work on explanations
  I use interface for '::'

Types
  Grammar:
    type_body = list<adt_con, '|', 1>?(list<arg>)?<inherit>?{ <body> }
    adt_con = <type>(list<type>)?
    inherit = <type><gen>? ':: '

  Inheritance:
    Spero provides two basic syntaxes to specify inheritance
      NOTE: This might change as I develop a more complete understanding of abstract types
      NOTE: There's no semantic difference between the two at the moment, but they are slightly different conceptually
      Spero types can only inherit from one "complete" type but can inherit from multiple "abstract" types

    Child-parent inheritance (ie. of complete types) is specified through '::'
      The location of the '::' typing can be on either side of the '=' in the assignment
        If the '::' is on the right, the syntax follows the Anonymous Types (ie. 'T ::')
	If the '::' is on the left, the syntax follws the type inference (ie. ':: T')
      Constructors of the parent class can be invoked through the 'super' keyword in the child's body
        A call to 'super' must be the first expression in the type body (a no-arg call will be inserted if none exists)
        Members of the parent type can also be accessed by indexing 'super'

    Interface inheritance (ie. of abstract types) is specified through the 'impls' statement
      This basically serves to 'import' any definitions into the current class
      The importing type will become an abstract type if an unimplemented interface remains
      A block, containing the relevant definitions, is allowed after the impls statement
        TODO: Look into requiring this block to exist
        TODO: Look into dropping the vcontext keywords for defining inherited functions

  Construction:
    There are three kinds of type constructors; primary, named, and secondary
      A type may only contain 1 primary constructor, but it may have multiple named/secondary
    The primary constructor merges the type body with the function body (ala Scala)
      All variables declared in the primary constructor are type members
      Annotations are applied to the primary constructor through the '@primary(..)' annotation
	Annotations would need to be placed above the type definition -> apply to the type
      An implicit, no-arg, primary constructor is automatically generated if one isn't provided
    Secondary constructors is implemented by overloading the static "new" method
      There are 2 general ways of implementing a secondary constructor
	Create and modify a mutable instance (uses another constructor)
	"Complete" the type definition ala Anonymous Types
	  This is needed in case the behavior of another "constructor" is not desired
      NOTE: he primary constructor is implicitly implemented in these terms
    Named constructors are Spero's way of implementing Algebraic Data Types (ADTs)
      Match statements can distinguish between named and primary/secondary constructors
        Type instances always remember which (named) constructor they were built with
      Named constructors disable the implicit creation of a primary constructor
    Constructors can be marked with '@explicit' to prevent usage in implicit resolution
      NOTE: Named constructors are always explicit

  Destruction:
    Destructors are implemented by overriding the 'drop' method with no arguments
      This method is specially recognized by the compiler so we don't need to mark it as '@mutable'
        The annotation is "implicitly" added by the compiler, so mutation of internal state is allowable
    Destructor calls are implicitly inserted by the compiler
      Insertions are done in 2 locations: scope exit and an enclosing type's 'drop' method
      These insertions are done in reverse order of declaration
    Destructors can be explicitly called if desired/necessary
      The variable is marked as "dropped" and is invalid until reassignment/shadowing
        It is valid to still "own" the memory for optimization purposes
      Implicit destructor calls are not inserted for explicitly dropped variables

Anonymous Types
  Grammar:
    <type> <tuple>? ::: <cons>? <scope> <tuple>?
  
  Anonymous types enable instantiating/extending types at the use site
    When bound to a type, this is the syntax for creating a child type
    When bound to any other name, this creates an instance of the type
      These types have access to the surrounding scope (through closures), so no arguments are needed
        Experimental: However primary/secondary constructors can be defined and used if desired
          The constructor is called by placing an argument tuple after the type body
      These types cannot declare named constructors
  
  The parent types constructor can be called in one of two ways
    Through a call to super in the type body
    Following the parent name by an argument tuple (this can be translated to the former)

Inference
  The typings of variables in Spero is largely inferred by the compiler
    TODO: Learn about type inference
  Type hints can be provided by the programmer using ':: T' syntax
    This is mainly useful for return overloading selection but can also perform up/down-casting
  Type inference may select a less specific base type when a derived is produced
    A ':: T' may be bound to a name/generic or to an expression
      Experimental: Both positions perform largely the same functions
  Casting is done through explicit/implicit constructions or dedicated cast methods
    So a "T -> String" is performed with the 'T:toStr' method

TODO:
  Look into restricting 'impls' to abstract types and '::' to complete types
  Start designing the type system
  Look into typeclasses
  Look into building in variant types ("T | V")
  Look into higher-kinded types
  If I can throw an error if a method is not marked '@mutable', I can throw an error if any method is used
    Why am I making the programmer write the annotation then? IDE support, helpful explicitness