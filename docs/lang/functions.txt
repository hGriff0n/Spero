Functions

  A function is defined as a collected sequence of code with a defined entry point and set of exit points. Execution of the function starts off at the entry point and continues, following the otherwise defined semantics of the language, until it encounters one of the exit points, at which point control is returned to the calling code. These semantics allow for the repeated usage and modularization of algorithmic steps.

  Arguments may be passed to the function body if the definition declares them as supported. These arguments are bound to the scope of the function body before any other statements in the function are executed. If the function is defined entirely using dot-forwarding, it is not necessary for these arguments to have an associated name, rather an accepted type. These arguments are immediately forwarded on to the function body (without decomposing the tuple).

  NOTE: This isn't the correct description of how arguments are handled (binding removes elements from the tuple)
  TODO: Improve the wording of this
  TODO: Need to find a place to add in 'partial application' (before overloading)

Syntax
  type signature: (Params...) -> Ret		# NOTE: Shorthand for the alternate syntax
    alternate: Function[(Params...), Ret]
  calling: `see syntax.txt`
  definition: `see syntax.txt`

Function Overloading

  Spero as a language supports the capability for function definitions to be "overloaded", that is that multiple behaviors may be associated to the same logical 'name'. A new overload is created by assigning to a logical name a new function that differs either in the type of the return or in the product typing of the parameter tuple from a pre-existing definition that was previously bound to the assigned name.

  Calls to an overloaded function are disambiguated through a strict algorithmic procedure that matches the calling arguments to the available parameter lists to pick out a "best" match.

  TODO: Define "best"

  NOTE: This process must make an unambiguous decision (compiler error otherwise)
  NOTE: Overloads are only created if the new assignment occurs in the same scope as the old assignment
    Otherwise normal variable shadowing rules apply.
  NOTE: It is allowable for any implementing compiler to produce an error if a new overload would subsume
    (or be subsumed by) an existing overload. However, this is not required by the standard

NOTE: Some of the assertions, especially in regard to overloading and inference, are entirely theoretical at this point. I have no idea how to implement them

Operator Overloading

  Operator overloading is a specialized form of function overloading that can change the behavior of binary/unary operators. Binary operators are defined generally as any series of non-alphanumeric characters (that otherwise hold no meaning to Spero). The behavior of these operations can be modified by assigning a function taking one argument to the operator (ala. "def <op> = (t) -> ...") within the lhs type body.

The behavior of the specified unary opeators can be customized by assigning a no-arg function to the operator within the operand's type body. The "names" of unary operators is predefined within the standard and cannot be redefined or moved.

  TODO: Improve the wording of this section
  TODO: Figure out a way to add in order-insensitivity
  NOTE: Compound assignment is not provided by Spero. It can be mimiced with mutable assignment

Object interaction

  Non-static member functions (ie. functions declared within the context of a type body) automatically have an implicit "self :: Self&" first parameter inserted into the body. If the function is marked as "mut" (through attaching `mut` before the argument tuple), then the typing of the `self` parameter changes to `mut Self&`, thereby allowing the oject to be mutably altered. An additional 'super' keyword is defined that serves to force selection of inherited definitions in the child type (especially when the child overrides the implementation).

  Variable resolution will implicitly attempt to index into this parameter if lookup fails to find a definition in the immediate scope (but before the global/higher context). It is always possible to explicitly index into the 'self'/'super' keyword and access the variable definitions if needed, although it will be an indexing error if such a definition doesn't exist. Note that 'self' and 'super' are keywords and cannot be shadowed so there is no ambiguity about what the behavior of this statement should be.

  TODO: Mention static member functions
  TODO: Mention how to call member functions
  NOTE: New variables cannot be defined on 'self'/'super'. Spero only allows old-variables to be modified

Coroutines


Functions
  Dot-Forwarding
    Dot-forwarding indicates that the function's arguments should be directly passed to the function body
      Roughly analagous to an implicit cut-and-past with a dot-flipping call
        NOTE: Actual implementation probably shouldn't follow this pattern

    Any function body that begins with a '.' (or 'mut .') is subject to dot-forwarding
      If no argument tuple for the function is provided, one is inferred from the body
        An overload set may be created based on the body of the function
	  The overload set is the maximal set of valid typings given for the body
      If an argument tuple is provided, argument names may be dropped (ie. Types only)
        This tuple mainly serves to restrict the overload set to "coherent" typings

Function Calling
  Grammar: See 'syntax.txt'

  Function evaluation within Spero is an eager process
    Lazy evaluation can be mimiced with streams/generators/captures/etc.
    When the function is evaluated can be moved by the compiler

  Dot-Flipping
    Dot-flipping allows functions to be called in an "infix" fashion
      The preceding atom is considered to be the first arguments to the function
        Note: "n - 1.factorial" => "n - {1.factorial}", not "{n - 1}.factorial"
      When invoked, the atom is inserted before the other arguments in the tuple
        ie. "T.fn(...)" is equivalent to "fn(T, ...)
        Experimental: If the "caller" is a n-ary tuple, tuple application applies
      When used with operators, dot-flipping upgrades to the level of functions
        Note: Dot-ops stil require parenthesis for the moment

  Omitting Parentheses:
    Parentheses can be omitted when a no-arg function is called
      Except in the case of constructing types (due to metaprogramming considerations)
      Renaming a no-arg function presents a bit of a syntactical challenge:
	One option is to create a forwarding lambda, ala "let <name> = .<fn>"
	Another option is to disable no-paren calling, ala "@disable(no_paren)let <name> = <fn>"
        A third is to use "importing" to rebind the name, ala "use <fn> as <name"
      NOTE: This may change in the future to simplify the process of renaming no-arg functions
        In the meantime, 'use-as' rebinding allows for the same semantics
    Parentheses cannot be ommitted to perform default type construction
      This is to allow for nicer metaprogramming syntax
        ie. "Int" refers to the `Int` type object and not a default `Int` value (ie. "Int() => 0")

  Var-arg functions
    If a function's final argument has a view typing, it is "var-arg" parameter
      The function will accept 0+ T's being passed at the end
        This T's will be grouped into a Sequence[T] container/view (ie. 'Array[T, n]')

  Overload Resolution
    5 modes of overload matching: Exact, Polymorphic, Generic, Implicit, None
      Exact       <- Exact type match, 'Arg == Param'
        Note: Var-arg matches are considered to be at the "exact" level
      Polymoprhic <- Subtype relationship, 'Arg :: Param'
      Generic     <- Generic matching, '[Param]'
      None        <- Failure state
      Implicit    <- Construct from the arg, 'Param:new(Arg)'
        Only one level of non-explicit constructors are considered for Implicit matching
        Experimental: The entire argument set may be considered for overloads with only 1 parameter
      Note: These are given in the rank order used by the resolution algorithm

    TODO: Go over this entire resolution process and reword it
    The resolution process goes similarly to this
      Choose all functions of name f into the overload set
        If there are any arguments, add a small weight to all functions T:f where T = type(f.params[0])
      From the overload set, choose all functions, f, so that
        The match on f.return is no worse than any other overload	# NOTE: What if I or'd these
        The worst match on f.params is no worse than the match on any other overload
      If more than one such function exists in the overload set, reduce as follows
	f is a member function (ie. has the 'T:f' weight)
        The mutability match on f.params is no worse than any other overload
      A dispatch (overload resolution) error will occur if one of the following applies
	No function was selected by the overload process (no overload exists)
	2 or more functions were selected by the overload process (multiple overloads exist)

Partial Application
  A partial application is a function with some arguments bound from a prior call site
    Note: All unbound arguments are at the end of the parameter list

  A function call reduces to a partial application iff
    Overload resolution fails because of too little arguments
    A possibly valid overload may exist, given the current arguments
    The resulting function is stored/used (variable/argument/return)

  The partial function maintains the same overload set as the parent function
    Minus all overloads that would be invalid given the bound arguments
    This inheritance is local to the time that the function was created
      ie. Overloading the function afterward should not affect partial application

  Positional Currying of Operators
    Binary operators can have different semantics depending on if a value is bound to the left or the right
    Binding a value to the lhs is trivial to perform ("<value> <op>")
    Binding a value to the rhs requires a workaround with dot-forwarding (".<op> <value>")
      Note: Currently, parenthesis are not needed for currying operators but are needed for indexing
        Note: This contradicts earlier statements

  TODO: Need to add in language to enable partial-application resolution

  Experimental: Can be disabled through the '@disable(curry)' annotation 	# Change name?

Coroutines

Experimental Ideas:
  Define '+' for functions, so "f + g" creates a function 'h', "h(...) = f(...) + g(...)"

TODO:
  Add in better language for partial application resolution
  Improve wording and understanding of var-arg recognition in overload resolution
  Add in language to account for 'mutable' methods