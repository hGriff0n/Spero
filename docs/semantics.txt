
Keywords
  Keywords have two general modes of operation, "basic" and "normal"
    normal keywords have a higher degree of language compatibility (ie. dot-flipping, etc.)
    basic keywords are more a more terminal part of the language

  Grammar:
    normal -> match | if | while | loop | for
    basic  -> mod | use | let | def | static | else | elsif

  Keywords:
    mod			        <- declare module name for the current context
    use			        <- module importing and rebinding/aliasing
    match		        <- perform pattern matching on the arguments
    if | else | while		<- standard usage
    for	| break		  	<- standard usage
    continue		    	<- standard usage
    def | let | static		<- visibility keywords
    mut			        <- mark the resulting value as mutable for the moment
    impls		        <- type inheritance/extension
    yield | return  		<- standard usage

Safety
  Like most languages, Spero aims to provide programmer safety
    However, the safety of some code (particularly low-level implementation) can't be verified by the compiler entirely
    These segments would normally cause the compiler to produce an error
      However, Spero provides the capability to selective tell the compiler to "trust me"

  Safety Propogation:
    A function is considered to be unsafe iff
      At any point in the function definition, an unsafe expression is evaluated
      The expression is not marked with the '@safe' annotation
      The expression is not wrapped within an expression that is marked with the '@safe' annotation
    The program entrypoint must be considered safe in final analysis for compilation to succeed
    It is possible to hand-mark some functions/etc. as unsafe through '@unsafe'

  Unsafe Operations:
    TODO: Determine what operations make a segment unsafe

Mutability
  Immutable by Default:
    All values in spero are immutable by default			# Note: This extends to variables/arguments
      That is, the value cannot be modified through reassignment or calling mutable methods
      A mutable typing can be indicated by prepending the 'mut' keyword to any <valexpr>
        NOTE: The exact rules are a bit tricky for where this placement is valid, best to only use in assignment
	NOTE: The inferred type would be 'mut T', where 'T' is the type of the <valexpr>
      Mutability of variables is not maintained in shadowing/assignment unless a 'mut' is used

  Typing Interaction:
    Mutability is a part of the type system (ala C++'s 'const')
      'T' is immutable, 'mut T' is mutable
      A 'mut' must be bound to a type name
	ie. can't write "def foo = (f :: mut) -> {}"		# NOTE: May change in the future
    Mutable methods (the '@mutable' annotation)
      Mutable methods (ie. methods that mutate internal state) must be annotated with '@mutable'
      Immutable types do not have access to any mutable methods (ie. can't call them on immutable instances)
        It is also a compiler error to mutate internal state from an immutable method
          mutate internal state = reassignment or calling mutable method
      TODO: Find a way to enable conditional behavior based on mutability
    It is possible to mark types as mutable-only with '@mutable'
      This makes it a compiler error to create immutable instances/alias of the type
    Experimental: It is possible to mark types as immutable-only with '@disable(mut)'
      Similar to mutable-only, it is a compilation error to create mutable instances

TODO: Clear up explanations and definitions
Generics
  Grammar:
    \[list<gen_arg, 1>\]
    gen_arg  -> <type_gen> | <var_gen>
    type_gen -> <type> (+|-|..)? ((::|!:|<|>) <type>)?
    var_gen  -> <var> ((:: <type>) | (= <val>))?

  Generics are a way to write code irrespective of the types of arguments
    Spero also supports "dependent" style generics by allowing values along with types in generics
      Like bindings, whether a generic parameter takes a type or a value is determined by the name
      Types and values have implicit subtype relationships if none are given at the creation site
        Experimental: Types implicitly add a ':: Type'
	Values have an implicit ':: Size'
    The syntax for subtying in Generics is rather simple
      :: -> The instantiation type must implement the interface
      !: -> The instantiation type must not implement the interface
      <  -> The instantiation type must be a subtype
      >  -> The instantiation type must be a supertype
    Experimental: Co-/contra- variance can also be indicated on type generics
      The syntax for covariance is to add a '+' after the type parameter (contra = -)

  Variadics within generics
    Varags are useful when all objects have a specific type in them
      But to capture any type, we must use the 'Any' type to allow compilation
    Variadics fixes this by allowing the generics system to capture a sequence of types by name
      Instead of a sequence of values, a variadic compiles into a tuple (known at compile-time)
    Variadics are indicated through the same syntax as varargs, the '..' after the type
      Implementation/etc. restrictions can be indicated after the '..' through the standard means

  Value Restrictions:
    Restrict to basic types for now
      The key thing, is that equality must be computable at compile time
    Experimental: In order for types to be used in generics, 2 conditions must be met
      The type's "eq" method has the @pure annoation (is computable at compile time)
      The instantiation's value is known at compile-time

  Instantiation:
    Explicit Instantiation is performed by providing concrete types/values for a generic context
      It is only considered for expressions (specializations are for lhs of assignments)
    Explicit instantiation of functions/types is not needed if the compiler can infer the correct overload
      NOTE: This is experimental for types as there may be some benefit to not allowing it (see "base" type)

  Generic definitions can be specialized for specific types/conditions
    This is done by providing concrete values in a generics array (same syntax as creation)
      Functions can also be "specialized" through overloading with an explicit argument tuple
      The complete type/function body must be provided to create a specialization
	This can be slightly shortcut for types through inheritance/imports
    A "base" type (no generics) can also be defined with the same name (minus '[]')
      Note: These are all unique "types", there is no aliasing/magic occuring
      NOTE: Experimental, as this implies C++ style generics (ie. T[V] can't operate on private members of a T[W])
	This might be a very good idea given "complete the definition" syntax/semantics (ie. private members aren't guaranteed to exist, only public members)

  Instance Resolution:
    Definitions
      Instance - The requested frame that is being matched
      Declaration - The generic "frame" that is being matched
      Definition - The concrete implementation for a given declaration
    There are 3 modes of generic declarations (in order of rank)
      Specialized <- [Int]      | [3]
      Subtyped    <- [T :: Num] | [v :: Num]
      Default	  <- [T]        | [v]		<- Defaults are Subtyped with 'Type' and 'Size' respectively
    Instance resolution follows largely the same process as overload resolution
      or every argument in the instantiation, no match can be worse than another instantiation
      A compiler error is produced if no declaration could be found
	A valid declaration will always be found if a default case exists
      If two matching declaration are found (of the same rank), a compiler error is produced
	Otherwise the resolution is well-formed by taking the highest ranked declaration

  Variables:
    Generics can be applied to non-function bindings the same as any other type
      This allows the variable to be accepted in any context that it's value is constructible to
        NOTE: The bound value should have the form 'T(...)' but it is not required yet

    The variable can be "instantiated" to a specific type in one of three ways
      Implicit conversion, ie. for functions, etc.
      Instantiation with an explicit template parameter
      Inference (ie. ':: T'), this basically follows from implicit conversion

  Variadics and Covariance
    Generics can also be implemented to accept a sequence of different types by appending a '..' to the generic type
      TODO: Explain more
    This variadics take up the syntactical spot for indicating co/contra-variance (ala Scala)


TODO:
  Figure out monads
  What should the behavior of 'static' be in local scopes 
  Determine what the default "unsafe" expressions should be
  Find a way to make def/let meaningful in local contexts (ie. not types/modules)
  Explain variadics and covariance in generics