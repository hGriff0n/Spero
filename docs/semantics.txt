
Keywords
  Keywords act largely the same as in many other languages, as reserved identifiers
    However, Spero augments some keywords with a degree of compatibility with dot-flipping and other semantics

  Grammar:
    mod                           <- declare module name for the current context
    use                           <- module importing and rebinding/aliasing
    mut                           <- mark the next value/expression as mutable
    impls                         <- type inheritance/extension/trait implementing
    def                           <- mark a binding as publicly visible
    let                           <- mark a binding as privately (protected) visible
    static                        <- mark a binding as statically bound
    match                         <- perform switch-style pattern matching. can be dot-flipped
    if                            <- standard usage. can be dot-flipped
    elsif | else                  <- standard usage
    while                         <- standard usage. can be dot-flipped
    loop                          <- loop infinitely ("while true"). can be dot-flipped
    for                           <- for-each style looping with pattern matching. can be dot-flipped
    break | continue | return     <- standard usage. can be dot-flipped
    yield                         <- produce a value from a re-entrant function. can be dot-flipped
    wait                          <- re-enter a re-entrant function and wait for a value. can be dot-flipped


Safety
  Spero aims to provide programmers with a usable language that prevents unsafe and dangerous practices
    The safety of some code, particularly low-level implementations, can't be verified by the compiler
      The target domain of Spero (systems-level like C++, Rust) requires that these areas by "codable"
      Spero follows Rust in allowing the programmer to mark these sections as "understood"
        This is valid so long as the unsafe behavior does not "leak" from the section
        This is performed by attaching the '@safe' annotation to the enclosing scope
    Programmers can also mark some sections as "unsafe" through the '@unsafe' annotation
      When applied to a binding assignment, any use of the bound name will be considered as "unsafe"
      TODO: Why would they do that?
    TODO: What does the compiler do and doesn't do inside of "unsafe" expressions

  Safety Propogation:
    The unsafety-ness of an operation propogates up the call tree until a "@safe" annotation is encountered
      Note: Of course, this propogation also stops once it reaches the global declaration level
    In final program analysis, the entrypoint function must be considered as "safe"
      Otherwise, a compiler error will be produced
      Note: The default entrypoint is 'main'

  Unsafe Operations:
    TODO: Determine what operations make a segment unsafe

Mutability
  Immutable by Default:
    All values/variables/arguments in spero are immutable by default
      Immutability means that modification, through reassignment/mutable methods, is prohibited
        Note: This applies even within unsafe blocks
      Mutability can be marked by preceeding the value/variable/etc. with the 'mut' keyword
        Note: The rules on the placement is somewhat complext at the moment
      Mutability is extremely transient - it is not maintained in assignment/usage by default

  Typing Interaction:
    Mutability is a part of the type system (ala C++'s 'const')
      A 'T' is an immutable 'T', a 'mut T' is a mutable 'T'
        TODO: Do mut rules change this ???
      'mut' must be bound to a value/variable/type, it is not "free"
	ie. can't write "def foo = (f :: mut) -> {}"
    Mutable methods are any method that mutates internal state
      These methods must be marked with the '@mutable' annotation
        This annotation changes the typing of the implicit 'self' paramter from 'Self&' to 'mut Self&'
        Note: Only "mutable" members are modifiable with mutable methods
      It is a compiler error (mutability) to call a mutable method on an immutable instance
        Note: Due to 'mut&' typing, modifying state in an immutable method produces a compiler error
      TODO: Find a way to enable conditional behavior based on mutability
    Types can be marked as "mutable"-only using the '@mutable' annotation
      This makes it a compiler error to hold a immutable instance/alias of the type
      Experimental: An alterante syntax is to simply use the 'mut' keyword
        ie. "def T = mut { ... }" is equivalent to "@mutable def T = { ... }"
    Experimental: It is possible to mark types as immutable-only with '@disable(mut)'
      Similar to mutable-only, it is a compilation error to create mutable instances

TODO: Clear up explanations and definitions
Generics
  Grammar:
    \[list<gen_arg, 1>\]
    gen_arg  -> <type_gen> | <var_gen>
    type_gen -> <type> (+|-|..)? ((::|!:|<|>) <type>)?
    var_gen  -> <var> ((:: <type>) | (= <val>))?
 
  Generics are a way to write polymorphic code that type-checks at compile-time
    Spero allows values as well as types to be used within generics as arguments/parameters
      Note: This means Spero should support Pi-types
    Like normal bindings, generic parameters distinguish acceptance based on capitalization
      ie. 'T' expects a type, 't' expects a value
    Subtype restrictions in generics follow a rather simple syntax
      ::   -> The argument must implement the following interface
      !:   -> The argument must not implement the following interface
      <    -> The argument must be a subtype of the following interface
      >    -> The argument must be a supertype of the following interface
        Note: The last two are a bit-iffy about acceptance
        Note: Values have a default sub-typing of ':: Size'
        Experimental: Types have a default sub-typing of ':: Type'
    Experimental: Co-/contra- variance can also be indicated on type generics
      The syntax for covariance is to add a '+' after the type parameter (contra = -)

  Variadics (T..):
    Varags are useful when the sequence has a singular type (for ad-hoc polymorphism)
      But sometimes a subtyping relation does not exist or it is impossible to correctly type-check the code
    Variadics fixes this by extending generics to capture a sequence of types
      Variadics use the same syntax as varargs, '..', but it is attached to the type in the generics "window"
      Instead of a sequence of values, a variadic compiles into a tuple (known at compile-time)
        Note: Subtyping relations can be added after the '..'
    Note: Instead of a Vararg-Sequence, variadics are collected into a tuple
    TODO: Think of moving the '..' into the subtype area, or prohibiting any other "decorators"

  What Kinds of Objects are Usable in Generics:
    All types are usable as type arguments
    Currently, only a predefined set of types are usable as value arguments
      Note: Current set is { Int, Float, Byte, Char, Bool }
    Experimental: It is possible to create a custom type that can be used in generics
      The key thing for any value types, is that equality must be compile-time computable
        I guess there must also be a way to create compile-time literals as well

  Instantiation:
    Explicit Instantiation is providing concrete types/values for a generic use context
      ie. "Vec[Int]" would be explicit instantiation of 'Vec[T] with T=Int'
    This is different from implicit instantiation which infers the correct values from context
      This is mainly used by functions, but type constructors can also make use of it
      ie. "Vec(3)" infers the instantiation type "Vec[Size]"

  Specialization:
    Definitions can be given special behavior for specific type/value combinations
      Specialization follows the same syntax as normal generic declarations
        The only difference is that values are given, instead of the "placeholder" names
      Functions can alternately be specialized through overloading the name
    The complete type/function body must be provided for specialization, ie. no interfaces
      Note: This work is slightly reduced with types through inheritance/imports
    Note: Specializations could theoretically allow users to break code "accidentally"
      ie. "T[I] = {}" ... "T[Int] = { @abort! }"

  Instance Resolution:
    Definitions
      Instance - The requested frame that is being matched
      Declaration - The generic "frame" that is being matched
      Definition - The concrete implementation for a given declaration
    There are 3 modes of generic declarations (in order of rank)
      Specialized <- [Int]      | [3]
      Subtyped    <- [T :: Num] | [v :: Num]
      Default	  <- [T]        | [v]
    Instance resolution follows largely the same process as overload resolution
      For every element of the current instance, no match can be worse than another
      A compiler error is produced if no declaration could be found
	A valid declaration will always be found if a default case exists
      If two declaration are found of the same rank, a compiler error is produced
	Otherwise the resolution is well-formed by taking the highest rank

  Usage of Generics in non-Type (ie. Variable) bindings:
    Spero's semantic design strongly implies all bindings should access the generics system
      For variables, this mainly gets us an ability to extend the contexts a value is acceptable in
        Note: This is mainly done by forming the value as "T(...)", but not required
    Generic variables can be "instantiated" to a concrete type in one of 3 ways
      Implicit conversion, ie. in functions/etc.
      Explicit instantiation with the generic argument
      Type-Annotation (ie. ':: T'), this basically follows from implicit conversion

  Co-/Contra-variance
    TODO: Explain More

Modules
  A module is a collection of declarations that provide some encapsulation without using types
  TODO: Explain more, figure out where to put this
  TODO: Figure out how modules should be resolved

Qualified Names
  Grammar:
    module_path type_path (<var>|<type>|<op>)
    module_path -> (<var>:)*
    type_path   -> (<type>:)*

  The qualified name is the full organizational path that the binding falls under
    "std:io:println" refers to the "println" binding in the "std:io" module
      Similarly, "Int:abs" is the "abs" binding in the "Int" type
    All bindings in Spero can be accessed using their full qualified name
      TODO: Figure out how to resolve this process
    All variables within the qual_field are automatically interpreted as modules
      Note: Except for the last variable in the chain (ie. is there a ':' after?)

TODO:
  Figure out how monads would work
  What should the behavior of 'static' be in local scopes 
  Determine what the default "unsafe" expressions should be
  Find a way to make def/let meaningful in local contexts (ie. not types/modules)
  Explain variadics and covariance in generics