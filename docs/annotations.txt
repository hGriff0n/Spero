
Grammar
  @<variable>!?<tuple>?

Annotations
  Annotations are a system for the programmer to provide various hints and guarantees during compilation
    These guarantees can be used to provide tighter analysis, optimization and code generation
      Some are also helpful with in-code documentation efforts (ie. '@todo')
    Annotations are removed and applied in the early compilation passes

  Querying compilation state can be achieved in some annotations through special variables
    These annotations largely correlate to system/context-specific codegen controls
      ie. generating windows specific code iff the target machine has a windows os
    ie. "@enable_if(target.machine.os == os.windows) ... @enable_if(target.machine.os == os.mac) ..."

  Annotations are split into local and global versions
    Local annotations are applied to singular statements in a Spero program
      Specifically, the are attached to the next encountered statement while parsing
      These allow for a local, fine-grained degree of control from the programmers perspective
    Global annotations are marked by the presence of a '!' character at the end of the annotation name
      Global annotations apply to the entirety of the current context block (where they exist)
        Syntactically, they are considered to be statements themselves
        TODO: Is it possible to annotate global annotations?

Current recognized annotations:
  immutable - Make it a compiler error to hold an object/type in a mutable context
  safe      - Mark a block of unsafe code as "safe" to execute
    Accepts an optional string literal clarifying why the code segment is "safe"
  unsafe    - Mark a block of safe code as "unsafe"
  todo      - Raise a warning
  asm       - Output assembly code for the target architecture
  static    - marks an assignment as having "static" scope

Ideas for annotations:
  explicit  - Mark a constructor as "invalid" for implicit construction resolution
  truthy   - Specify a method to be used for converting values of a type into Booleans
    Takes a function, which must have the signature "() -> Bool" (compiler error otherwise)
  mutable  - Control codegen based on the mutability of 'self'
    '@mutable(true, [false], [object=self])'
  mem_limit - restrict the amount of memory a type/module/etc can use
  enable    - turn on language features that were disabled
  assert    - raise an error (compiler/runtime) if a condition evaluates to false
  cassert   - raise a compiler error if a condition evaluates to false
  force     - requires/disables language features to create environment
  pure      - promise that the function is "pure" for optimization purposes. may allow use in generics
  disable   - turn of a language feature for some time
  primary   - apply annotations to the primary constructor instead of the type
  if_cfg    - conditional compilation based on compilation target
    alternately: enable_if
  hide_warn - turn off specific compiler warnings
  show_warn - turn on specific compiler warnings
    Could possibly merge into enable/cfg
  delta     - epsilon equality tests for doubles
  intrinsic - compiler provided method/type definition. file only specifies interface
    Basically, Spero code defines an abstract type but you can still instantiate it
  final     - mark methods/classes as unoverridable/un-subtypable

Creating custom annotations:
  No method currently exists for allowing programmers to create custom annotations
  This is partially due to the lack of knowledge regarding compile-time execution and reflection support

Ideas:
  Expand annotations to be able to make macros with them
  Find a way to create custom annotations in user code
  Look into extending safe with "assert", require compile-time code that can evaluate to true/false
