
Grammar
  @<variable><fn_call_args>

@pure:
  This annotation promises that the function is "pure"
    Might also indicate that the function is compile-time computible

  For now, leave it as a simple promise
  	It may be possible to add in some basic checking in the compiler

@mutable:
  Restrict a method/type to only be available on mutable instances
  TODO: Decide if '@mutable { .. }' should export '..' into the parent scope (NOTE: Not yet)

@disable(..):
  Turn off language features for a given expression

@primary(..):
  Apply annotations to the primary constructor (and not the type)

@explicit:
  Mark a constructor as "invalid" for implicit construction resolution

@safe(..):
  Mark a block of unsafe code as "safe"
  The programmer can supply a string literal clarifying why the code segment is "safe"
    A compiler warning will be produced otherwise
  Idea: May allow for "invariant functions", static code that must be true for the segment to be safe

@unsafe(..):
  Similar behavior to '@safe', but marks the following section as "unsafe"

@todo(..):
  The compiler will raise a warning on any todos (and comments as well)

@asm(..):
  Write the given assembly code

@truthy(fn):
  Specifies a method to be used for converting this type into Booleans (mostly for if/while statements)
  Function must take no arguments and return a Bool or its a compiler error (ie. signature = "() -> Bool")

Annotations
  Modes:
    Global
      These annotations apply to the current modules
        Third-party code cannot be changed through in-language annotations
      Annotations with a '!' at the end of the name are automatically global
    Local
      These annotations apply to the next expression/block/function/type
    Querying
      Some annotations are usable in querying modes for conditional compilations
	NOTE: Experimental
  Support:
    Some annotations may support global and local operations but it is not required
      It's also possible to have global annotations be unique (ie. '@safe' != '@safe!')

Ideas
  Expand annotations to be able to make macros with them

Annotation Ideas
  mem_limit   <- restrict the amount of memory a type/module/etc can own
  precedence  <- set operator precedence
  dead_code   <- warning if unused code is found in the compiler (disables)
  cfg	        <- stronger conditional compilation
  error_def   <- ??
  assert      <- raise a compiler error if the condition evaluates to false
  force       <- analagous to '@disable', requires language features for evaluation 
  enable      <- opposite of '@disable'

  Need way to turn off compiler warnings for specific segments
    @disable works for names, but need a more general solution

Syntax ideas
  @annotation
  @annotation(<args>)
  @annotation { ... }
