
Manual Memory Management
  The Problem:
    Manual Memory Management (ie. pointers) is a key source of many programming issues
      Many languages restrict or hide the use of pointers to the programmer
    However, Spero is designed to be a safe, systems-style language
      As such it needs to have the ability to directly interface with hardware memory

  The Solution:
    Spero provides three Memory "types": Pointer(T&), mem:Addr, and mem:Chunk
      Addr represents a single location in memory
	Most operations with Addr are inherently unsafe (Addr can be anything)
      Chunk represents an owned heap segment
	Chunks must be mutable and are slightly safer than Addr (due to ownership)
	  A chunk's memory is freed when it's destructor gets called
      Addr and Chunk can be used to implement pointers (Pointers provide type safety ensurance)

    The 'mem' module provides implementations for many other memory operations
      Most of these operations are needed to implement other standard modules

  Pointers (T&):
    A pointer is basically a Chunk[T.size] with some syntactic sugar
      A Chunk represents a sequence of bits, a pointer represents that sequence as a value of a given type
      TODO: Look into whether reference counting can be statically determined
      When a pointer is freed (no references), the types destructor is called before the memory is released

    Pointers are dereferenced by binding a '&' before an expression
      A single '&' will bind to the maximal index sequence after it
        It will only bind after the end of a function call/index sequence by default
      More complex dereference schemes require wrapping the expression in '{}'
        Calling a function poitner is one such operation (ie. '{&fn_ptr}(3)')
          Note: '()' are required to call no-arg functions even after dereference
      Pointers may define '&' operators (based on operator existence for the pointed type)
        NOTE: Experimental (I don't have a way of defining the operators per type)

    Mutability (ie. 'mut T&') does not apply to the pointer, but to the reference type
      So 'mut T&' /> 'mut (T&)' but instead -> '(mut T)&'

  There are three methods for the creation of Pointers (Note: currently)
    alloc(T) -
      allocates space enough to store the passed element
      equivalent to allocn(T, 1)
    allocn(T, n) -
      allocates space enough to store n copies of the passed element
      equivalent to allocg((Size) -> T, n)
    allocg((Size) -> T, n) -
      allocates space enough to store n instances of type T (basically an Array[T, n])
      calls the given generator function at each index of the "array" to get a value to store in the space

  This means that pointer arithmetic, etc. is not possible on pointer types
	  It is possible on Addr (and maybe Chunk), but it is an unsafe operation
      Pointers additionally enforce another restriction in in regards to multiple pointers of one object
        A mutable pointer cannot be made to an immutable object under any circumstances
        Two such pointers cannot exist such that one is mutable and the other is immutable

  Safety:
    Due to lifetime resolution reasons, it's not possible to safely make a local pointer
      Rust solves this with generics, but that might only be possible through additional syntax
	  This is something I want to allow in safe code, but I'm not sure it's possible to analyze yet
      Safe pointers are restricted to 'mem:alloc' calls
      Local pointers can be created with the 'mem:ref' function, however 'mem:ref' is an unsafe operation
    Currently, there is also a special case of iterators, 'ref_iter' (also unsafe)
      This iterator allows modifying a containers elements through the iterator, not through the container
        Note: This can provide a slight efficiency improvement, but I can't find a way to generalize it

Views (T*) and Collections
  Views are a lightweight and general way of accepting varargs and collections in the same function
    Types must implement Iterable[T] in order to match a T* for assignment/argument matching
  '[..]' is a syntactical sugar for creating an Array[T, n]
  Varargs are also a sugar for an Array[T, n]
    Varargs can only be used as the last parameter of a function

TODO:
  allocn/allocg produce arrays, pointers are situated for single elements
    Can i resolve this under the current semantics