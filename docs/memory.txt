What do I need?
  1. A way to mark and use a section of memory for implementation
    Select and reserve a 'n byte' sized chunk of memory
    Allow typesafe modifications to those 'n bytes'
  2. (Opt) A way to enable reference semantics in function calls
  3. A way to use specific sections of memory for implementaion
  4. An easy way of typing a sequence of elements
  5. (Opt) A way of maintaining typing on a sequence of elements of diverse typing (without relying on 'Any')
    This is especially useful to enable "forwarding" constructors

Memory:
  Everything is stack-allocated unless otherwise specified
    NOTE: This includes custom types

NOTE: Very preliminary idea, not quite ready to be accepted
References:
  References are a simple and lightweight way to pass variables by-reference into functions
    NOTE: Much of this design is taken from C++ style references
  If taken by a mutable reference (ie. 'mut T&'), any modifications to the argument are maintained in the calling variable

Views:
  A view is a lightweight sequence of values of any length that can be accepted as the last arguments to a function
  A view is indicated in an argument list by appending the type name with two dots ('..') ala Ranges
    TODO: Explain more about this
  NOTE: Needs more explanations

References:
  Spero adapts the C++ concept of references to enable a lightweight, yet safe, method of performing call-by-reference
  This is extremely important in the realms of implementing OOP methods, especially mutable methods
    Member methods take, by default, a 'T&' as the first parameter. This is bound to the 'self' name
    Mutable methods take a 'mut T&' instead to allow for mutating the internal state
  References also enable a rather simple method of reducing memory usage and copies
    A possible optimization is to turn any parameters of 'T' into a 'T&' where the change doesn't affect compilation

Current Framework Idea:
  TypeTraits - Abstract class that all types implement to provide various memory information
    Note: Since all types implement this, I might modify this idea in the future
    size - field specifying the number of bytes that the type takes up. provided by the compiler
    align - field specifying the ABI alignment multipler. every valid address of T must be a multiple of this
    sizeof - method that basically wraps to returning size. Not static
      Note: It might be better to have these as "free-functions" (from a size standpoint)
    alignof - method that basically wraps to returning align. Not static
  Addr - Type to represent an address in memory. Addr's must be explicitly created
    Note: Aside from typing enforcement, the purpose of Addr is slightly unclear
  Chunk - Type to represent a section of memory. Little more than a (Addr, Size, Bool) tuple. Must be mutable?
    drop - Method to safely deallocate a Chunk and prevent future usage. Also marks the Chunk as free for reallocation.
      Note: This does not zero-initialize the memory segment (needed for some mmio behavior)
      Note: This does not call any destructors as it has no conception of underlying types
    forget - Method to prevent drop from marking memory as free for allocation use.
    view_as[T] - Method to reinterpret the Chunk as an 'Element[T]' object for more type-ful operations. Optional offset arg.
      Note: This interface needs a lot of work and thought
    apply - Create a sub-chunk with the given offset. Possibly allow an optional 'size'/'end' argument.
      Note: This is meant to enable '()' semantics for the "Chunk.view_as" model
    for_each[T] - Method to iterate over each 'T' in the 'Chunk' (as if it was an array of 'Element[T]')
      Note: Is there a way to enable 'for_each(fn)' and 'for_each.map!(fn)' ??? Perhaps 'iter_each' method
  TyChunk[T] - Type to represent a single 'T' in heap memory. Intermediary between a Chunk and 'T' in typing
    set - Method for setting the memory segment to the given value of 'T'
    get - Method for getting the memory segment as a raw instance of 'T'
    construct - Method that constructs a 'T' in place given the argument list
    destroy - Method to call the destructor for 'T' on the memory segment
    Note: 'TyChunk[T]' does not have a 'drop' method as that would interfere with 'Chunk:view_as' operation
  Ptr[T] - Type to represent a smart pointer that can't be reassigned. Typed as 'T*' or 'mut T*' (to indicate mutability)
    borrow - Mutable method to borrow the pointer for some computations. Prevents usage until borrow is released
    copy - Method to automatically copy the pointer (not the data)
    deref - Special method called to extract the data from the pointer if a 'T' or 'T&' is expected
    drop - Method to safely handle deallocation, releasing borrow, and "smart" status when pointer is destroyed
  RPtr[T] - Type to represent a smart pointer that can be reassigned. Typed as 'T mut*' or 'mut T mut*'
    Note: RPtr[T] has all the same methods as Ptr[T] plus the following for reassignment
    TODO: Determine reassignment functions for RPtr[T]
  alloc - Function to allocate a chunk of 'n bytes'. Returns a Chunk
  alloc[T] - Function to simplify allocating a known type. defined as "alloc(T.size * n)"
  malloc[T] - Function to allocate and return a 'T*' object (Ptr[T])
  ralloc[T] - Function to allocate and return a 'T mut*' object (RPtr[T])
  calloc[T] - Function to allocate and initialize a single element. Can be defined in terms of "alloc"
  reserve - Function to mark addresses as off limits for allocation. Useful for memory mapped devices and implementation
    Note: This could be moved as a member of Addr. Semantics not needed however

Rust std::mem
  replace         - replace the memory with a new value, returning the old one
  forget          - like Chunk:forget, but more general (Stack values, et al)
  swap
    memswap(Addr, Addr, Size)
  transmute       - reinterprets value of one type as another type
  transmute_copy  - copy then transmute
  uninitialized   - returns a value of T without initializing memory

C++ <memory>
  allocators      - different allocation strategies
  memcpy          - copies the bytes
    memcpy(Addr, Addr, Size)
  addrof          - get the address of the value

Other needs
  Interactions with Chunk/Addr/Chunk1
  memzero

TODO:
  Settle on a memory model for Spero
  Should I provide a method to allocate at a given address ???
  Need to determine how deref should work for allowing modifications to the existing memory
  Need to add a way to get the 'Type' object from a type value