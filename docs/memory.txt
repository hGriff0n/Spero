What do I need?
  1. A way to mark and use a section of memory for implementation
    Select and reserve a 'n byte' sized chunk of memory
    Allow typesafe modifications to those 'n bytes'
  2. (Opt) A way to enable reference semantics in function calls
  3. A way to use specific sections of memory for implementaion
  4. An easy way of typing a sequence of elements
  5. (Opt) A way of maintaining typing on a sequence of elements of diverse typing (without relying on 'Any')
    This is especially useful to enable "forwarding" constructors

Memory:
  Everything is stack-allocated unless otherwise specified
    NOTE: This includes custom types

NOTE: Very preliminary idea, not quite ready to be accepted
References:
  References are a simple and lightweight way to pass variables by-reference into functions
    NOTE: Much of this design is taken from C++ style references
  If taken by a mutable reference (ie. 'mut T&'), any modifications to the argument are maintained in the calling variable

Views:
  A view is a lightweight sequence of values of any length that can be accepted as the last arguments to a function
  A view is indicated in an argument list by appending the type name with two dots ('..') ala Ranges
    TODO: Explain more about this
  NOTE: Needs more explanations

Current Framework Idea:
  TypeTraits - Abstract class that all types implement to provide various memory information
    Note: Since all types implement this, I might modify this idea in the future
    size - field specifying the number of bytes that the type takes up. provided by the compiler
    align - field specifying the ABI alignment multipler. every valid address of T must be a multiple of this
    sizeof - method that basically wraps to returning size. Not static
      Note: It might be better to have these as "free-functions" (from a size standpoint)
    alignof - method that basically wraps to returning align. Not static
  Addr - Type to represent an address in memory. Addr's must be explicitly created
    Note: Aside from typing enforcement, the purpose of Addr is slightly unclear
  Chunk - Type to represent a section of memory. Little more than a (Addr, Size, Bool) tuple. Must be mutable?
    drop - Method to safely deallocate a Chunk and prevent future usage. Also marks the Chunk as free for reallocation.
      Note: This does not zero-initialize the memory segment (needed for some mmio behavior)
      Note: This does not call any destructors as it has no conception of underlying types
    forget - Method to prevent drop from marking memory as free for allocation use.
    view_as[T] - Method to reinterpret the Chunk as an 'Element[T]' object for more type-ful operations. Optional offset arg.
      Note: This interface needs a lot of work and thought
    apply - Create a sub-chunk with the given offset. Possibly allow an optional 'size'/'end' argument.
      Note: This is meant to enable '()' semantics for the "Chunk.view_as" model
    for_each[T] - Method to iterate over each 'T' in the 'Chunk' (as if it was an array of 'Element[T]')
      Note: Is there a way to enable 'for_each(fn)' and 'for_each.map!(fn)' ??? Perhaps 'iter_each' method
  Element[T] - Type to represent a single 'T' in heap memory. Intermediary between a Chunk and 'T' in typing
    set - Method for setting the memory segment to the given value of 'T'
    get - Method for getting the memory segment as a raw instance of 'T'
    destroy - Method to call the destructor for 'T' on the memory segment
    Note: Current framework has 'Element[T]' extending Chunk. Need to decide on interchangability with Chunk and T
    Note: 'Element[T]' does not have a 'drop' method as that would interfere with 'Chunk:view_as' operation
  alloc - Function to allocate a chunk of 'n bytes'. Returns a Chunk
  alloc[T] - Function to simplify allocating a known type. defined as "alloc(T.size * n)"
  valloc[T] - Function to allocate and initialize a single element. Can be defined in terms of "alloc"
  reserve - Function to mark addresses as off limits for allocation. Useful for memory mapped devices and implementation
    Note: This could be moved as a member of Addr. Semantics not needed however

  Pointer[T] - Type to represent a smart pointer (currently reference counted) to an immutable object
    borrow - Method to borrow the pointer as a Pointer[T]
    borrow_mut - Method to borrow the pointer as a Pointer[mut T]
    make_imut - Method to make a Pointer[T] from the pointer, reusing memory (ie. no copy) if possible
    make_mut - Method to make a Pointer[mut T] from the pointer, reusing memory if possible
    copy - Method to force a Pointer[T] by copying the pointed data
    copy_mut - Method to force a Pointer[mut T] by copying the pointed data
    deref - Special method called if a method expects a 'T' and a 'Pointer[T]' is provided instead
    drop - Method to safely handle deallocation and reference counting for pointer types
  MutPointer[T] - Type to represent a smart pointer to a mutable object. 'deref' returns a mutable X object
    Note: Syntactical sugar for pointers is provided in the form of "T&" and "mut T&" for argument
      "T&" -> "Pointer[T], "mut T&" -> "Pointer[mut T]". These pointers are not reassignable
    Note: Do I need a 'forget' method for pointers ???
  calloc[T] - Function to allocate and return a 'T&' object.
    Note: Seperate functions are necessary to enable simple semantics while keeping the syntax and understandability clean
  malloc[T] - Function to allocate and return a 'mut T&' (usefulness unclear)
    Note: IFF 'T&' are a seperate type (They would be a reference counted Chunk with better typing and safety)
    Note: Can I get 'malloc', et al., to have a "forwarding" mode

Rust std::mem
  replace         - replace the memory with a new value, returning the old one
  forget          - like Chunk:forget, but more general (Stack values, et al)
  swap
    memswap(Addr, Addr, Size)
  transmute       - reinterprets value of one type as another type
  transmute_copy  - copy then transmute
  uninitialized   - returns a value of T without initializing memory

C++ <memory>
  allocators      - different allocation strategies
  memcpy          - copies the bytes
    memcpy(Addr, Addr, Size)
  addrof          - get the address of the value

Other needs
  Interactions with Chunk/Addr/Chunk1
  memzero

TODO:
  Settle on a memory model for Spero
  Should I provide a method to allocate at a given address ???
  Need to determine how deref should work for allowing modifications to the existing memory
  Need to add a way to get the 'Type' object from a type value