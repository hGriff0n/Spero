mod dec_tree
use std:_:_

##
Note: I'm making a lot of the interfaces up here
##

def main = (args :: String*) -> {
    let examples = readFile(args(0).or_else("test.data"))

    for e in examples do
        "{}".println(e.classification)

    "{}".println(DecTree:construct(examples, Range(0, examples.size())))

    "--------".println()
    for e in examples do
        "{}".println(e.classification)
}

let readFile = (file :: String) ->
    File(file).lines().collect[Vec[Example]]()

let Example = (attr :: String) {
    def classification = attr(0)
    def attr = attr(Range(2)).grouped(2).map(_.0).Vec
}

let computeError = (examples :: Vec[Example], range :: Range[Size]) -> {
    let counter = mut Map[Char, Size]()
    { counter(e.classification) += 1 }.for e in examples(range)
    max(count(Range(0)), (l, r) -> l.1 < r.1).1 / range.size()
}
let computeError = (idxs :: Vec[Size], examples :: Vec[Example]) -> {
    let counter = mut Map[Char, Size]()
    { counter(e(i).classification)++ } for i in idxs
    max(count(Range(0)), (l, r) -> l.1 < r.1).1 / idxs.size()
}
let computeError = (examples :: Vec[Example]) -> computeError(examples, Range(0, examples.size())

let bestDecision = (examples :: Vec[Example], taken :: Vec[Size]) -> {
    let sort_set = mut Map[Size, Map[Char, Vec[Size]]]()
    for e in examples.zipWithIndex() {
        for dec in e.0.attr.zipWithIndex().filter(!taken.contains(_.1))
            sort_set(dec.1)(dec.0).push_back(e.1)

    max(sort_set, _.1.reduce((acc, entry) -> acc + computeError(p.1, examples))).0
}

let partition = (examples :: mut Vec[Example]&, attr_vals :: Vec[Vec[Char]], dec :: Size, range :: mut Range[Size]) -> {
    let partition_points = Vec[Size]()

    for val in attr_vals(dec) {
        let (left, right) = partition(examples, range, _.attr(dec) == val)
        partition_points.push_back(left)
        range = right
    }

    return partition_points
}

# DecTree must be serializable
let DecTree = (err :: Float) {
    let nodes = mut Vec[DecTree]()
    let decision :: Option[Size] = mut None

    static construct = (examples :: mut Vec[Example]&, range :: Range[Size]) ->
        Self:construct(examples, range, Vec())

    static construct = (examples :: mut Vec[Example]&, range :: Range[Size], taken :: Vec[Size]) -> {
        let dec = mut computeError(examples, range).DecTree()

        if dec.err != 0 {
            dec.decision = bestDecision(examples(range), taken).Some()
            taken.push_back(dec.decision.unwrap())

            let partition_points = partition(examples, Vec(), dec.decision.unwrap, range)
            for range in partition_points
                dec.nodes.push_back(DecTree:construct(examples, range, taken))
        }

        dec
    }
}

impl Serializable for DecTree {

}
