## TODO
Get pointers and memory management to work better

Explain rules better
##

Manual Memory Management

For a normal user, Spero provides two memory types: View (T*) and Pointer (T&)
	Mutability for these types is a bit different from other types
		It is not possible to make a mutable view or pointer
		It is possible to make a view or pointer to a mutable type
			ie. 'mut' applies to 'T' not 'T*'
		Additionally, you can't hold a mutable and normal pointer to the same memory
	Pointers and Views own their memory
		This "ownership" is possibly enforced through a "ref-counting" principle
			This can possibly be statically determined
		When the last pointer is finally de-allocated, the memory is freed
			If there is an associated type, the type destructor is first called

Pointers and Safety
	Due to lifetime resolution reasons, it's not possible to safely make a local pointer
		Pointers are restricted to alloc calls inside of normal code
		Local pointers can be created in "safe" code through the ref function
	This is something I want to make safe, but it depends on the compiler
		Given Rust, the only way to statically check might be through extra syntax

Implementation (the 'mem' module)
	mem provides two implementation types, Addr and Chunk([n])
		'Addr' represents a memory address
			Operations with 'Addr' are inherently unsafe
			'Addr' is mostly useful with 'as[T]' casts
		Chunk represents an owned memory segment on the heap
			Chunk memory are mutable by default (ie. write works)
			Mutability is only restricted if an explicit type is associated to it
				ala through "mem:alloc[T]"

	Pointers/Views can be implemented in terms of 'mem:Chunk'
		Spero just provides syntax/method sugar and safety guarantees

Views and Sequences
	A view is a lightweight way of accepting varargs and containers in the same function
		Views are non-owning ranges in all cases (varargs are on the stack ??)
		In order to be accepted as a view, a type must implement the 'Iterable' interface
			This may change in the future (to get more restrictive)
	[1, 2, 3, 4] is a syntactical shortcut for creating an Array[T, n]
		Array implements the View interface (as it's a sequence)


# Memory usage sheet

let addr = 0x3a5f.mem:Addr		# Memory Address
let cnk = mem:alloc[4]			# Heap <- static checking?
let vck = mem:alloc[Int.size * 10]	# Heap
let rck = mem:alloc(16)			# Heap <- runtime?
let ptr = mem:alloc[mut Int]		# Heap <- mut Int&

let x = &(addr.as[Int])			# unsafe
let y = ar.read[Char]			# safe (copy)
let z = &ptr				# safe

addr.write('Z')				# unsafe
&(rck.as[mut Int]) = 3.3		# unsafe
&ptr = 5				# safe

let ptr = ptr
let dup = mut ptr			# Error: mut Int& and Int& to same memory

let dup = ptr
let ptr = mut ptr			# Error: mut Int& and Int& to same memory

let ptr = mut ptr
let dup = ptr				# Error: mut Int& and Int& to same memory

let ptr = ptr
def foo = (mut Int&) -> ()
foo(ptr)				# Implicitly converted to 'mut Int&' for the call
let dup = ptr
foo(ptr)				# Error: mut Int& and Int& to same memory

let x = 10
@safe {
	foo(x.ref)			# Can do a local pointer in the safe block
}

{
	let ptr = mem:alloc[mut Int]
	&ptr = 15
}					# ptr is deallocated here (and the int is deleted)