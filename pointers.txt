## TODO
Explain rules better
##

Manual Memory Management

For a normal user, Spero provides two memory types: Views (T*) and Pointer (T&)
	Mutability for these types is a bit different from other types
		It is not possible to make a mutable view or pointer
		It is possible to make a view or pointer to a mutable type
			ie. 'mut' applies to 'T' not 'T*'
		Additionally, you can't hold a mutable and normal pointer to the same memory
	Pointers own their memory
		This "ownership" is possibly enforced through a "ref-counting" principle
			This can possibly be statically determined
		When the last pointer is finally de-allocated, the memory is freed
			If there is an associated type, the type destructor is first called
	Views are slightly different in memory terms
		A T* can be any type that implements Iterable[T]
		Varargs can be implicitly converted to an Array[T] (or similar collection)
	Dereferencing Pointers
		A pointer can be dereferenced by binding a '&' before an expression
		A '&' binds before any '.', so parens are necessary for more complex constructions
		Additionally several operators can have '&' definitions for pointers
			So "ptr &= 5" can assign a 5 to the memory owned by ptr

Pointers and Safety
	Due to lifetime resolution reasons, it's not possible to safely make a local pointer
		Pointers are restricted to alloc calls inside of normal code
		Local pointers can be created in "safe" code through the ref function
	This is something I want to make safe, but it depends on the compiler
		Given Rust, the only way to statically check might be through extra syntax

Implementation (the 'mem' module)
	mem provides two implementation types, Addr and Chunk([n])
		'Addr' represents a memory address
			Operations with 'Addr' are inherently unsafe
			'Addr' is mostly useful with 'as[T]' casts
		Chunk represents an owned memory segment on the heap
			Chunk memory are mutable by default (ie. write works)
			Mutability is only restricted if an explicit type is associated to it
				ala through "mem:alloc[T]"

	Pointers/Views can be implemented in terms of 'mem:Chunk'
		Spero just provides syntax/method sugar and safety guarantees

Views and Collections
	Views are a lightweight way of accepting varargs and collections in the same function
		They are guaranteed to use a minimal number of memory allocations
		Types must implement Iterable[T] to be accepted as a 'T*'
	[1, 2, 3, 4] is a syntactical shortcut for creating an Array[T, n]
	Varargs is a syntactical shortcut for creating an Array[T, n]
		Varargs can only be used as the last parameter of a function


# Memory usage sheet

# Making a pointer
let addr = 0x3a5f.mem:Addr		# Memory Address
let cnk = mem:alloc[4]			# Heap <- static checking?
let vck = mem:alloc[Int.size * 10]	# Heap
let rck = mem:alloc(16)			# Heap <- runtime?
let ptr = mem:alloc[mut Int]		# Heap <- mut Int&

# Reading a pointer
let x = &(addr.as[Int])			# unsafe
let y = ar.read[Char]			# safe (copy)
let z = &ptr				# safe

# Writing a pointer
addr.write('Z')				# unsafe
&(rck.as[mut Int]) = 3.3		# unsafe
&ptr = 5				# safe
ptr &= 7				# safe

# Pointer Errors
let ptr = ptr
let dup = mut ptr			# Error: mut Int& and Int& to same memory

let dup = ptr
let ptr = mut ptr			# Error: mut Int& and Int& to same memory

let ptr = mut ptr
let dup = ptr				# Error: mut Int& and Int& to same memory

let ptr = ptr
def foo = (mut Int&) -> ()
foo(ptr)				# Implicitly converted to 'mut Int&' for the call
let dup = ptr
foo(ptr)				# Error: mut Int& and Int& to same memory

let x = 10
@safe {
	foo(x.ref)			# Can do a local pointer in the safe block
}

{
	let ptr = mem:alloc[mut Int]
	&ptr = 15
}					# ptr is deallocated here (and the int is deleted)