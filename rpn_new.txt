#!
 ! A little test program to help work out the feasibility of the new argument syntax
 !  Key changes:
 !   match allows complete tuple decomposition (was restricted to tup_1)
 !   special arg tuple type to help with syntax (and metaprogramming)
 ! Also provides an introductory test bed for modules
 !
 ! The test program is a basic RPN calculator that supports (+,-,*,/,~)
 !#

mod RPN			## Declare a module
use std:io:*		## Import everything from std:io
use std:str		## Import the std:str namespace (can access with str:*)
			## Do I want to include scala import style (ie "use std:{io, str}:*" to import everything from std:io and std:str)

def main = getln .parse .eval .println("= {}")					## Dot-flipping is really nice

type Stack[T] = Empty | Cons(Stack, T)						## Define a stack as an ADT because I haven't gotten collections settled yet (plus pattern matching)

let parse = (:String) .groupWhile(str:isDigit)					## parse is not exported from the module (let-bound, ie. protected)
		      .removeIf(str:isSpace)
		      .reduce(Empty, (:Stack[Int], :String) .match {
				Cons(Cons(s_, l), r), "+" => Cons(s_, l + r)	## Decompose the stack into the top two elements to perform arithmetic
				Cons(Cons(s_, l), r), "-" => Cons(s_, l - r)
				Cons(Cons(s_, l), r), "/" => Cons(s_, l / r)
				Cons(Cons(s_, l), r), "*" => Cons(s_, l * r)
				Cons(s_, i), "~" => Cons(s_, -l)		## Use ~ as the unary negation
				s, _ => Cons(s, _.toInt)			## Push the number on the stack
		      })

	##  V This is the current idea for arguments, the argument tuple, the arg-name is optional if the arg is not directly referenced
	##  V	The syntax would be necessary as they would interfere with type tuple metaprogramming possibilities
let eval = (:Stack[Int]) .match {
	Empty => "nil"
	Cons(Empty, i) => i.toStr
	_ => "incomplete"
}

#!
Thoughts:
  The new syntax still needs some refinements to completely work, though I do think the switch-over should occur
    I completely forgot about type creation, I don't know how that'll be affected by the new syntax
      Generally it works, I just have to figure out how inheritance would be handled
    Need to make some examples that include the argument name, even if it's unnecessary (see if that's throwing me off)
      Also look into having a distinct argument syntax instead of duplicating the tuple syntax (ie. \ or something similar)
    The argument tuple distinction is a quick fix to mitigate collisions with type tuple metaprogramming
      Don't know how well those fears are founded however, need to wait until metaprogramming doodles
    I also have some doubts about functions with no arguments
      The are indistinguishable from variables (from all perspectives)
      This exists in the old syntax as well however

  Tuple decomposition matching works rather well
    I need to find a case where tuples and non-tuples are valid options to be in the same match
      Try to find a way for decomposition to introduce ambiguity
      Matching should still work with a composed tuple, though the ranking would probably be different
    Need to figure out how to add in contract matching

  Modules
    Using def/let to distinguish between visibility is a nice compromise
      Maintains expected behavior for new learners while maintaining the syntactical simplicity
    The import syntax needs some work however (it was cobbled together)

  There's a big problem with indexing and dot-flipping, namely their syntaxes clash
    Currently "Int.abs(3)" should parse to "abs(Int, 3)", which has no meaning
      Special casing won't cover all the cases adequately
      	Dot-flipping also has to work with keywords (such as match and if)
        There's no simple rule for saying "no dot-flipping" (esp. with lambda types)
      I could rewrite parametrics as being an implicit first parameter (of type "Type"), which would make the transformation meaningful
!#