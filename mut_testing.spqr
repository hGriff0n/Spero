

def foo = (x :: Int) {
    let x = mut x       # T => mut T. Copy
    x += 3
    let x = x           # mut T => T. Reuse
}

def foo = (x :: mut Int) -> foo(x)

def mfoo = (x :: mut Int) {
    x += 2
}

let Foo = {
    let arr = mut [1, 4, 3, 6].Vector[Int]

    if sys:now.hour < 12
        "WAKE UP!".println

    # Mutable-only methods
    @mutable
    def sort = () -> arr = arr.sort

    @mutable
    def push = (x :: Int) -> arr = arr.push_back(x)


    # This method has different behavior based on the object's mutability
    def pop = () ->
        arr.pop_back .if @mutable else "Pop!".println


    # Immutable methods
    def size = () -> arr.size

    def toStr = () -> arr.toStr


    # Custom constructors are implemented as methods (they're called on the created object, not the calling)
    def new = (mult :: Int) {
        let ret = mut Foo
        ret.arr.map!(* mult)
        ret
    }

    # Interesting possibility (The '{ ... }' is evaluated within the context of the constructed Foo)
    def new = (mult :: Int) -> Foo { arr.map!(* mult) }

    # Doesn't call through the default constructor
    # Attempt 1: Use `alloc`
    def new = (arr :: Int*) {
        let ret = mut alloc[Foo]
        ret.arr = Vector(arr)
        ret
    }

    # Attempt 2: Disable construction
    def new = (arr :: Int*) {
        @disable(constructor)           # @construct(false)
        let ret = mut Foo
        ret.arr = Vector(arr)
        ret
    }
}

def main = () {
    let x = 3
    let x = x               # T => T. Optimize

    foo(x)                  # f(T) => f(T). Reuse
    "{}".println(x)         # Should print '3'

    mfoo(x)                 # f(T) => f(mut T). Copy
    "{}".println(x)         # Should print '3'

    let r = x               # V = T. Alias
    let x = x + 3           # T => T. Reuse

    "{}".println(r)         # Should print '3'
    
    {
        using t = x         # Alias

        let x = mut 2
        "{}".println(t)     # Should print '6'
    }

    let f = Foo
    "{}: {}".println(f.size, f)

    # sort modifies f
    f.sort
    "{}: {}".println(f.size, f)
}