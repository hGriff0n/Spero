let Showable = {
    def toStr :: () -> String
}

@comment("This comment is tied to the class")
# This comment is not (ie. Can't be seen with reflection)
let Numeric = {
    def + :: (Numeric) -> Numeric
    def - = .neg + self
}

@comment("Demonstrating mutability restrictions")
def Int = Numeric {
    @mutable
    def += = (n: Numeric) -> self = self + n            # only valid on `mut Int`

    def add = (Numeric) -> .+ self                      # valid on `Int` and `mut Int`

    @pure def == :: (Numeric) -> Bool

    @pure def + :: (Numeric) -> Int
}

# BigInt is showable and numeric
def BigInt = (num :: String) {
    use {Numeric, Showable}                             # Same syntax as module imports (possible problems)

    def toStr = () -> num
    def + = (val :: Numeric) -> BigInt(num + val.toStr)
}

##
This is also valid
def BigInt = (num: String) Numeric{         Sugar for "use Numeric"
    use Showable

    def toStr = num
    def + = (val: Numeric) ->
        BigInt(num + val.toStr)
}
##