##
A little test program to help work out the vs-spero extension and for settling the function syntax
The test program is primarily a basic RPN calculator with some non-rpn functions
##

@todo {
	"Write stuff in this annotation"
	"The syntax for todo might need some work"
}

mod rpn
use std:{io, str}:*

def main = .getln .parse .("={}".println)

adt Stack[T] = Empty | Cons(T, Stack) {
	def toStr = self .match {
		Cons(i, Empty) -> i.toStr
		_              -> "nil"
	}
}

let parse = (String) ->
	.groupWhile(isDigit)
	.removeIf(isSpace)
	.reduce(Empty, (a, b) .match {
		Cons(r, Cons(l, _s)), "+" -> Cons(l + r, _s)
		Cons(r, Cons(l, _s)), "-" -> Cons(l - r, _s)
		Cons(r, Cons(l, _s)), "/" -> Cons(l / r, _s)
		Cons(r, Cons(l, _s)), "*" -> Cons(l * r, _s)
		Cons(l, _s), "~"          -> Cons(-l, _s)
		s, _                      -> Cons(_.toInt, s) 
	})

let eval = (Stack[Int]) .match {
	Cons(i, Empty) -> i.toStr
	_              -> "nil"
}

let Cipher[T] = {
	def encode :: (T*) -> T*					# `encode` takes a T sequence and produces a T sequence
	def decode :: (T*) -> T*
}

# map[T, V] = (T*, (T) -> V) -> V*
# map[T] = (T*, (T) -> ()) -> ()
def Caeser = (shft :: Char) {
	use Cipher[Char]						# Inheritance/Interfaces

	def encode = .map (+ shft)				# Point-free functions
	def decode = .map (- shft)				# They inferentially meet the Cipher requirements
}

def test = (log :: Logger) {					# Can the '{' unpack the arg tuple ??
	log << ("{} {} +".fmt(3, 4) .parse .eval)
	log << ("{} {} + {} *".fmt(3, 4, 5) .parse .eval)
}

def arrayTest = (nums :: Int*) {
	let view = [1, 2, 3, 4, 5] ++ nums		# The language intrinsic is a view (or sequence)
	let arr = nums.toArray					# Array is a stdlib feature

	println("The first element is {}", arr(0))
}

def sortTest[T] = () {
	let (a, b) = (3, "I")									# Use `<>` if parsing doesn't work out

	[3, 4, 5, 1, 2].sort((a, b) -> a < b).toStr.println
}

def functionTest = () {
	def foo = () "Hello".println
	"Goodbye".println						# This is the only thing that should print
}

def split = (s :: String, i :: Int)	->
	s.zipWith(index)
	 .groupWhile(< i)
	 .map(.snd .mkString)					# How to access a tuple ???

def noargs = () {
	let person = "Enter your name: {}".std:io:getln
	let age = "Enter your age: {}".std:io:getln
	let (gen, race) = "Enter your gender: {}\nEnter your race: {}".std:io:getln

	"{person}, {age - 5}, {}, {race}".fmt(gen)			# You can evaluate expressions within the '{}'
}