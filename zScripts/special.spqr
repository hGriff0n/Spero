
def Array[T] = (n :: Size) {
    use {Mappable, Indexable}

    let ptr = mut alloc(T.size * n)

    @safe
    def at = (i :: Size) {
        @todo("Add range checking behavior. Possibly add in annotation querying?")
        
        Ok(ptr.sub[T](i))
    }

    @mutable
    def map! = (f :: (T) -> T) {
        let i = mut 0
        
        while i < n {
            at(i) = i.at.f
            i += 1
        }
    }

    def map[V] = (f :: (T) -> V) {
        let (ret, i) = mut (Array[V, n], 0)

        {
            i.at = at(i).f
            i += 1
        } .while i < n

        ret
    }
}

def Array[T, n :: Size] = Array[T] {
    let ptr = mut alloc[T.size * n]

    @safe
    def at = (i :: Size) {
        @todo("Add range checking behavior. Possibly add in annotation querying?")
        
        Ok(ptr.sub[T](i))
    }
}