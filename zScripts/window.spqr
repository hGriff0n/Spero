
let Copyable[T] = {
    static new :: (T) -> T
    def copy = (T) -> .T:new
}

def Wall = (h :: Size, w :: Size) {
    let windows = mut [].Vector[Window]

    # Would be a compiler error without the mutable annotation (windows.push_back is @mutable)
    @mutable
    def addWindow = (w :: Window) -> windows.push_back(w)

    def paintableArea = () ->
        h * w - windows.map(.getArea).reduce(+)

    def numWindows = () -> windows.size

    use Copyable[Wall]

    static new = (cpy :: Wall) -> Wall {
        windows = cpy.windows.cpy
    }
}

let Window = (w :: Size, h :: Size) {
    def getArea = .*(h, w)
}

def main = () {
    let (w, h) = "Input wall dimensions (w, h): {} {}".std:io:getln
    let wall = Wall(h, w)

    let (w :: Int, h :: Size) = "Input window dimensions (w, h): {} {}".std:io:getln
    "{}".println(wall.numWindows)


    # Compiler error: Attempt to call a mutable method on an immutable object
    #wall.addWindow(w, h)

    # Shadow wall as mutable to allow for a window to be added
    let wall = mut wall
    wall.addWindow(w, h)

    # This is an immutable copy
    let myWall = wall

    # This is a variable alias (any occurance of myw can be replaced by wall, 
    using myw = wall

    {
        using swall = wall      # alias are performed to the current binding
        let wall = 3            # swall and myw alias to the same object
    }

    # Shadow as immutable (I'm not going to add in an annotation to force immutability to call a function)
    let wall = wall
    "{}".println(myw.numWindows)            # myw is an alias to wall (so it's immutable here)

    "{}".println(myWall.numWindows)
}