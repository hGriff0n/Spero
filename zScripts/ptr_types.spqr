mod ptrs

use std:{mem, fs}:*

def Array[T, n :: Size] = {
    let ptr = mut alloc[T.size * n]

    @safe
    def at = (i :: Size) {
        @todo("Add range checking behavior. Possibly add in annotation querying?")
        
        Ok(ptr.sub[T](i))
    }

    use {Mappable, Indexable}

    @mutable
    def map! = (f :: (T) -> T) {
        let i = mut 0
        
        while i < n {
            at(i) = i.at.f
            i += 1
        }
    }

    def map[V] = (f :: (T) -> V) {
        let (ret, i) = mut (Array[V, n], 0)

        {
            i.at = at(i).f
            i += 1
        } .while i < n

        ret
    }
}

# Can I implement Vector in terms of Array ???
def VecArray[T] = {
    let ptr = mut Array[T, 10]
    let (size, cap) = mut (0, 10)

    @safe
    def at = (i :: Size) {
        if i < size
            Ok(ptr(i))
        else
            Error("Out of Range")
    }

    @mutable
    def push_back = (val :: T) {
        if size == cap {
            cap = 20
            let cur = ptr

            ptr = mut Array[T, 20]
            ptr.map!((i) -> &(cur.at(i))
        }
        
        ptr(size) = val
        size += 1
    }
}

def Vector[T] = {
    let siz = mut 0
    let cap = mut 10
    let ptr = mut alloc(cap)

    @mutable
    def push_back = (val :: T) {
        if size == cap {
            cap *= 2
            let cur = ptr

            ptr = mut alloc(cap)                    # 'mut' refers to the variable and the binding
            ptr.map!((i) -> &get(cur, i))
        }

        ptr(size) = val
        size += 1
    }
}

def Foo = () {
    use std:sys                                     # This is a problem (use is for inheritance, this is to bring std:sys into scope)

    let f = mut "f.txt".File
    "Default open at {}".writeln(f, sys:now)

    def new = (foo :: mut Foo) {
        f = foo.f.copy
        "Duplicate at {}".writeln(f, sys:now)
    }

    static delete = (foo :: mut Foo&) {
        "Closed at {}".writeln(f, sys:now)
    }
}

def main = () {
    Foo

    # These all get the 2nd element in the 'cnk' "array"
    using T = Int
    let cnk = mut alloc[Int.size * 5]
    cnk.sub[Int, 1]
    cnk.sub[Int](1)                             # unsafe '(1)'
    cnk.chunk[T.size, 2 * T.size].as[T]         # unsafe 'as'
}