## Let's start off with a simple "Cipher" trait
let Cipher = {
	def encode(msg: String) => String
	def decode(msg: String) => String
}

## Lets create an instance of our Cipher class
	## Like Java, we must supply implementations for the abstract methods
let caeser = Cipher {
	def encode(msg) = map msg (c) => c + 5
	def decode(msg) = map msg (c) => c - 5
}

## Lets expand our caeser cipher with a constructor
	## Technically this actually creates a function that returns a Cipher
let caeser (shft: Char) = Cipher {
	def encode(msg) = map msg (c) => c + shft
	def decode(msg) = map msg (c) => c - shft
}

caeser('C').encode("hello") = "JGNNQ"
caeser('C').decode("JGNNQ") = "hello"
let c_caeser = caeser('C')			## possible ??
c_caeser.encode("hello") .eq caeser('C').encode("hello")

#!
    This works, but what if we want to only accept caeser ciphers
	Unfortunately caeser is only an instantiation of Cipher, the type isn't workable
    Luckily the change is incredibly simple, trivial even
!#

## Types are indicated by capital letters, variables by lowercase, and operators by symbols
	## So by capitalizing the name we can a much more flexible construction
	## Not that the arg list contract now specifies the constructor for the type 
let Caeser (shft: Char) = Cipher {
	def encode(msg) = map msg (c) => c + shft
	def decode(msg) = map msg (c) => c - shft
}


## This is good for our purposes, but if we want to make a cryptography library
## We need to make our cipher trait a bit more generic over its encryption types
	## Modern ciphers work on collections of bits and not characters

## The syntax is (currently) borrowed from Scala (though not everything (yet))
let Cipher [T] = {
	def encode(msg: T*) => T*		## Take a sequence of T's and return such
	def decode(msg: T*) => T*		## Don't have arrays yet (might not)
}

## We can even protect against wrongful conversions through local types
	## Now you can only decrypt an encrypted message (and vice versa)
	## This doesn't work correctly yet
let Cipher [T] = {
	let EncType = T{}			## Protection's easily lost
	def encode(msg: T*) => EncType*		## Not composable at all
	def decode(msg: EncType*) => T*		## I think the relationship's reversed too
}

## So now how does our Caeser Cipher get modified
let Caeser (shft: Char) = Cipher[T] {
	def encode(msg) = map msg (+ shft)	## Lets take advantage of currying while we're at it
	def decode(msg) = msg .map (- shft)	## Prepending '.' turns map into an infix function
}

let String = Char*{}				## String is a subtype of a Char sequence