## TODO
Add in a way to restrict a type's mutability (force it to always mutable/immutable)
Look into adding in a way to "export" annotated scopes into the encompasing scope
##

built-in event loop (ala lever)
    easy to develop concurrency
    main would be a default

compiler raises warnings for every "TODO" in a comment
	or have a "todo" annotation (have both)

Compile-time execution (ala Ante)


Safety annotations (see Rust for better explanations)
	Some segments of code are inherently unsafe, but necessary
	These segments can be executed within a "safe" block through the '@safe' annotation
		This turns off some, but not all, compiler checks to
	If an unsafe function/operation is not surrounded in a "safe" block, the encompasing function is considered to be unsafe
		main (or the entry function) must be considered safe
	It's also possible to mark functions/etc. as "unsafe" through '@unsafe'

# Foo can only exist as a mutable object
@mutable
def Foo = { ... }

# Bar can't exist as a mutable object
@disable(mut)
def Bar = { ... }