## TODO
Specializing generics
===
Work on ref.spqr (might implement pointers and references this way)
Mutability as part of the type system
Reference and Pointers as classes
Have a private default constructor
Start designing the type system
##


# Generics Design sheet
using Reducable = Numeric | Traversable		# Local type alias

[T :: Type]			# Templated on a type T that inherits from Type
[T]				# Sugar for the above (all types inherit from the supertype `Type`)
[n :: Size]			# Templated on a value, n, that is a size (how will this work)
				# Note: There are some restrictions on value types in generics
[T, n :: Size]			# Templated on T and n (dependent typing ???)
[T :: Numeric | Traversable]	# T must be Numeric or Traversable
[T !: Reducable]		# T can't be Reducable
[T < Numeric]			# T must be a subtype of Numeric
[T > Int]			# T must be a supertype of Int

[Int]				# Generic specialization ???

# Co/contra-variance (don't know if the type system will included it though)
[T+]				# Covariance (if it's not the default)
[T-]				# Contravariance (A :: B => T[B] :: T[A])


## Generic Value Restrictions
For now, I should be able to restrict it to basic types
	However I want to be able to open it up to user types
	The value still has to be known at compile-time

In order for type values to be used in generics, 2 conditions must be met:
	The type's "eq" method has the @pure annotation
	The value is known (or inferable) at compile-time

@pure annotation
	For now, leave it as a simple promise (ie. this function has no side effects)
	It may be possible to add in some basic checking to ensure that the promise is kept
		For now though, pure is just a reminder to the programmer
			It doesn't guarantee the code is well formed
			This is why I'm restricting to basic types for now
##

# Syntax for defining algebraic data types
	# Special context needed because ADTs are a collection of constructors, not types (could I roll in the syntax ???)
adt Option[T] = Some(T) | None				# These names are technically types ???


# Syntax for defining custom structures
let Animal = { ... }

# Syntax for defining parametric structures
let Vec[T] = (n :: Size) { ... }

# Create a type with a constructor that takes a String
let Person = (name :: mut String) {				# Name is mutable by the class (syntax uncertain)
	static count mut = 0					# Mutable static field (mutable syntax uncertain)

	# How to access class fields from an instance, with ':' or '.'
	def new = (Person) -> .name.this			# Variable-less copy constructor (needs work)
	def hello = () -> println("Hello! I'm {name}!")
}


# Define Cipher trait (a type with unimplemented members)
let Cipher[T] = {
	let Enc = T{}
	def encode :: (T*) -> Enc*	# The '::' instead of the '=' is experimental (specifying a type signature contract)
	def decode :: (Enc*) -> T*	# Function signatures
}

# Should subtypes have to specify types of inherited functions ??
let Caeser = (shft :: Char) {
	use Cipher[Char]

	def encode = .map (+ shft)
	def decode = .map (- shft)
}


# Lambda Types and Inheritance
let caeser = Cipher[Char]{ ... }	# caeser is actually an instance of Cipher
let caeser = { use Cipher[Char] ... }	# same thing as above (above is sugar for this)


# Subtyping/Type restrictions
def foo = (x) { ... }		# args must support all methods called on x (but what differentiates this from a tuple with the value of x ???)
def foo = (x :: Numeric) { ... }	# args must inherit from Numeric (+ method support)
				# unless this isn't how inferrence works

# Casting
let i = 3
let s = i.toStr			# Definately in
let s = i.String		# If the constructor supports it (though behavior may differ)

let b = i :: String		# This is a boolean test (ie. does i match a String)


# Metaprogramming Design Sheet
[Int, Float, String]					# A type-list (types are instances of the Type superclass)
(Int, Float, String)					# A type-tuple (no '->' so not an argument tuple)

let type_list = List(Int, Array[Float], String)		# An actual list (has type `List[Type]`)
let alt_list = List(Int, Array, String)			# Should this be allowable (Array doesn't have a type parameter)

# Check that a type has a method
let is_splitable = type_list.map(? split)		# '?' inspection keyword-operator (works both ways, also considered 'has' keyword)
let is_splitable = type_list.map(.hasMethod("split"))	# Get the types that have a split method (inclusion depends on runtime support/compile-time aggresivenes)
let is_splitable = type_list.map(.methods.find(.name == "split"))

# Check that a type has a method with a given signature
let int_str = type_list.map(.? call :: (Int) -> String) # '?' inspects the method, '::' checks the signature ('?' has the higher precedence)

# Get a list of all methods that have a given signature
let int_methods = Int.methods.map(:: (Int) -> Int)

# Create an object from a type list (or have a collection of partially applied constructors)
let defaults = type_list.map(:new)