# Syntax for defining algebraic data types
	# Special context needed because ADTs are a collection of constructors, not types
type Option[T] = Some(T) | None


# Syntax for defining custom structures
let Animal = { ... }

# Syntax for defining parametric structures
let Vec[T] = (n: Size) {
	# T must be a type (ie. "T: Type", the ": Type" is filled in by default)
}

# Same but the size is now part of the type
let Vec[T, n: Size] = { ... }		# Values can be part of the parameter system
					# Does this enable dependent typing ???


# Local type alias (local types also allowed)
using Reducable: Numeric | Traversable


# Other Parametric stuff
[T: ^Numeric]			# T can't be Numeric
[T: Numeric | Traversable]	# T must be Numeric or Traversable
[T: Reducable]			# Same as above


# Create a type with a constructor that takes a String
let Person = (name: String) {
	static count mut = 0				# Mutable static field

	def this = (:Person) .name .this		# Copy constructor
	def hello = println("Hello! I'm {name}!")	# Method? With interpolation
							# What differentiates this from assigning to the result of an equation (see "variables" below)
}

# Standard Types
Size		# unsigned
Int		# signed
Float		# double


# Spero Design Sheet: Caeser

# Define Cipher trait (a type with unimplemented members)
let Cipher[T] = {
	let Enc = T{}
	def encode = (T*) => Enc*	# The current syntax I'm experimenting on
	def decode = (Enc*) => T*	# def specifies function signatures without require implementation
}

# Should subtypes have to specify types of inherited functions ??
let Caeser = (shft: Char) {
	use Cipher[Char]

	def encode = .map (+ shft)
	def decode = .map (- shft)
}


# Creating lambda types
let caeser = Cipher[Char]{ ... }	# caeser is actually an instance of Cipher


# Subtyping/Type restrictions
def foo = (x) { ... }		# args must support all methods called on x (but what differentiates this from a tuple with the value of x ???)
def foo = (x: Numeric) { ... }	# args must inherit from Numeric (+ method support)
				# unless this isn't how inferrence works

# Interfaces and Inheritance
def Caeser = (shft: Char) {
	use Cipher[Char]	# Is this the same or different than the current `use`
}

def Caeser = Cipher { ... }	# Sugar for { use Cipher ... }


# Metaprogramming
# TODO
