## TODO
Implement collections.spr (figure out views/etc)

Have a private default constructor
Start designing the type system
##

# Syntax for defining custom types (indicated by the capitalization)
let Animal = { ... }

# Syntax for defining generic types (indicated through the '[]')
let Vec[T] = (n :: Size) { ... }

# Types can be specialized in several ways
let Baz[T] = { ... }			# Base generic definition
let Baz[Int] = { ... }			# Specialize for 'T == Int'
let Baz = Baz[Int]{ ... }		# Create a non-generic instance that inherits from Baz[Int]
					# You can also have the non-generic as the "base"

# Create a type with a default constructor
let Person = (name :: mut  String) {		# Name is a mutable member
	static count = mut 0			# Mutable static field
	let age = mut 0				# Another mutable member

	# Use '.' to access class fields/methods from an instance
	def hello = () -> println("Hello! I'm {self.name}!")
}

# Constructors and Destructors
Additional constructors are implemented by overloading the static "new" method in one of 2 ways
	Create a mutable instance using another constructor and transform the members
	"Complete" the type definition
		The syntax for this is "<type> { <bindings> }"
			'let' members must be bound
			'def' members may be left unbound 	<- Abstract types
		This allows construction without calling a constructor
			The default constructor is implemented in these terms
			See "types.spqr" for a better representation of this
		
Custom destructor is implemented by overriding the static "drop" method
	The T:drop method takes a singular "mut T" as its argument
	Destructor calls are implicitly inserted in reverse order of declaration
		At the end of scopes and in a parent object's destructor
	Destructors can be explicitly called if desired with the following effects
		The variable that is "dropped" is invalid until it is reassigned/shadowed
			It still "owns" its memory location for optimization purposes
		The implicit destructor call is not added at the end of the scope
	

# ADTs can be implemented through "named" constructors
	# Might implement this through sub-typing
let Option[T] = Some(T) | None {}				# 'Option' construction is disabled

# You can re-enable 'T' construction by providing an "unnamed" constructor or creating "new" constructors
let Person = Noone | (name :: mut String) { ... }

# Types can be distinguished based on the constructor if ADT syntax is used
let Option[T] = Some(T) | None | () {
	def get = () -> self.match {
		Some(t) -> t
		Option -> 3		# 'T' construction is not distinguishable
	}
}

# Define Cipher trait (a type with unimplemented members)
let Cipher[T] = {
	let Enc = T{}
	def encode :: (T*) -> Enc*	# The '::' instead of the '=' is experimental (specifying a type signature contract)
	def decode :: (Enc*) -> T*	# Function signatures
}

# Should subtypes have to specify types of inherited functions ??
let Caeser = (shft :: Char) {
	use Cipher[Char]		# 'use' specifies impl/inheritance relations if in a type definition (module imports elsewhere)

	def encode = .map (+ shft)
	def decode = .map (- shft)
}


# Lambda Types and Inheritance
let caeser = Cipher[Char]{ ... }	# caeser is actually an instance of Cipher
let caeser = { use Cipher[Char] ... }	# same thing as above (above is sugar for this)


# Subtyping/Type restrictions
def foo = (x) { ... }		# args must support all methods called on x (but what differentiates this from a tuple with the value of x ???)
def foo = (x :: Numeric) { ... }	# args must inherit from Numeric (+ method support)
				# unless this isn't how inferrence works

# Casting
let i = 3
let s = i.toStr			# Definately in
let s = i.String		# If the constructor supports it (though behavior may differ)

#let b = i :: String		Error: i is not a function that can return a String
	# The '::' helps the compiler chose the correct return type for overloaded functions
let b = i :? String		# This is a boolean test (is i an instance of String)


# Generics Design sheet
using Reducable = Numeric | Traversable		# Local type alias

[T :: Type]			# Templated on a type T that inherits from Type
[T]				# Sugar for the above (all types inherit from the supertype `Type`)
[n :: Size]			# Templated on a value, n, that is a size (how will this work)
				# Note: There are some restrictions on value types in generics
[T, n :: Size]			# Templated on T and n (dependent typing ???)
[T :: Numeric | Traversable]	# T must be Numeric or Traversable
[T !: Reducable]		# T can't be Reducable
[T < Numeric]			# T must be a subtype of Numeric
[T > Int]			# T must be a supertype of Int

[Int]				# Generic specialization ???

# Co/contra-variance (don't know if the type system will included it though)
[T+]				# Covariance (A :: B => T[A] :: T[B])
[T-]				# Contravariance (A :: B => T[B] :: T[A])


## Generic Value Restrictions
For now, I should be able to restrict it to basic types
	However I want to be able to open it up to user types
	The value still has to be known at compile-time

In order for type values to be used in generics, 2 conditions must be met:
	The type's "eq" method has the @pure annotation
	The value is known (or inferable) at compile-time

@pure annotation
	For now, leave it as a simple promise (ie. this function has no side effects)
	It may be possible to add in some basic checking to ensure that the promise is kept
		For now though, pure is just a reminder to the programmer
			It doesn't guarantee the code is well formed
			This is why I'm restricting to basic types for now
##

# Constructors
	The primary constructor is defined through the type definition
		The '(...)' defines any needed arguments (note this is optional and defaults to no arguments)
		The '{ ... }' defines the constructor body (what gets executed)
			TODO: Find a way to split off invariants from class members
	Secondary constructors are implemented as static "new" methods
		The return type for these methods is the calling type
		Implement by creating a mutable instance of the calling type then modifying what is necessary
		It is possible to disable the default constructor from running any code (just setup and allocation)
			TODO: Finalize the syntax (T:alloc or @disable(constructor)
	Note: Construction is always performed on mutable instances
	Objects can be constructor be "calling" the type name (ie. T(...)) or by calling the new method (ie. T:new(...)
		The former is implemented as the latter internally

# Generic Spcialization
There are 2 possibilities for generics
	Basic: [T|n :: T]		# There can't be 2 basics with the same ordering and size (compiler error)
	Concept: [T :: C]

Specialization resolution
	If an instantiation matches a concept or a basic, the instantiation is well-formed
	If an instantiation matches a concept and a basic, the instantiation is well-formed
	If an instantiation matches multiple concepts, a compiler error is produced
	If no instantiation can be found, a compiler error is produced

def sort[T] = (T*) { ... }		#a
def sort[T !: Sortable] = (T*) { ... }	#b
def sort = (Numeric*) { ... }		#c

let arr :: Int* = [4,3,5,2,1]
sort(arr)			# c	Int* :: Numeric*
sort([arr])			# a	Int** !: Numeric*, Int* :: Sortable
sort(['d', 'a', 'z', 'r'])	# b	Char* !: Numeric*, Char !: Sortable


# Metaprogramming Design Sheet
[Int, Float, String]					# A type-list (types are instances of the Type superclass)
(Int, Float, String)					# A type-tuple (no '->' so not an argument tuple)

let type_list = List(Int, Array[Float], String)		# An actual list (has type `List[Type]`)
let alt_list = List(Int, Array, String)			# Should this be allowable (Array doesn't have a type parameter)

# Check that a type has a method
let is_splitable = type_list.map(? split)		# '?' inspection keyword-operator (works both ways, also considered 'has' keyword)
let is_splitable = type_list.map(.hasMethod("split"))	# Get the types that have a split method (inclusion depends on runtime support/compile-time aggresivenes)
let is_splitable = type_list.map(.methods.find(.name == "split"))

# Check that a type has a method with a given signature
let int_str = type_list.map(.? call :: (Int) -> String) # '?' inspects the method, '::' checks the signature ('?' has the higher precedence)

# Get a list of all methods that have a given signature
let int_methods = Int.methods.map(:: (Int) -> Int)

# Create an object from a type list (or have a collection of partially applied constructors)
let defaults = type_list.map(:new)

# Test if a function is defined in the current scope
self ? foo