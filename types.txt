## TODO
Work on generics
Work on metaprogramming doodles
Start designing the type system
##

# Generics Design sheet
using Reducable = Numeric | Traversable		# Local type alias

[T :: Type]			# Templated on a type T that inherits from Type (all types inherit from the supertype, Type)
[T]				# Sugar for the above
[n :: Size]			# Templated on a value, n, that is a size (how will this work)
[T, n :: Size]			# Templated on T and n (dependent typing ???)
[T :: Numeric | Traversable]	# T must be Numeric or Traversable
[T :: !Numeric]			# T can't be Numeric
[Int]				# Invalid in a declaration (valid in use)

# Co/contra-variance
[T+]				# Covariance (if it's not the default)
[+T]
[T-]				# Contravariance (A: B -> T[B]: T[A]) (covariance is the default behavior)
[^T]
[T^]				# Invariance (if it's not the default)
[?T]


# Syntax for defining algebraic data types
	# Special context needed because ADTs are a collection of constructors, not types
type Option[T] = Some(T) | None				# These names are technically types ???


# Syntax for defining custom structures
let Animal = { ... }

# Syntax for defining parametric structures
let Vec[T] = (n :: Size) { ... }

# Create a type with a constructor that takes a String
let Person = (name :: String) {
	static count mut = 0					# Mutable static field (mutable syntax uncertain)

	# How to access class fields from an instance, with ':' or '.'
	def this = (Person) -> .name.this			# Variable-less copy constructor (needs work)
	def hello = () -> println("Hello! I'm {name}!")
}


# Define Cipher trait (a type with unimplemented members)
let Cipher[T] = {
	let Enc = T{}
	def encode :: (T*) -> Enc*	# The '::' instead of the '=' is experimental (specifying a type signature contract)
	def decode :: (Enc*) -> T*	# Function signatures
}

# Should subtypes have to specify types of inherited functions ??
let Caeser = (shft :: Char) {
	use Cipher[Char]

	def encode = .map (+ shft)
	def decode = .map (- shft)
}


# Lambda Types and Inheritance
let caeser = Cipher[Char]{ ... }	# caeser is actually an instance of Cipher
let caeser = { use Cipher<Char> ... }	# same thing as above (above is sugar for this)


# Subtyping/Type restrictions
def foo = (x) { ... }		# args must support all methods called on x (but what differentiates this from a tuple with the value of x ???)
def foo = (x :: Numeric) { ... }	# args must inherit from Numeric (+ method support)
				# unless this isn't how inferrence works

# Casting
let i = 3
let s = i.toStr			# Definately in
let s = i.String		# If the constructor supports it (though behavior may differ)

let b = i :: String		# This is a boolean test (ie. does i match a String)

# Metaprogramming
[Int, Float, String]		# A type-list
(Int, Float, String)		# A type-tuple (no '->' so not an argument tuple)
