## TODO
Work on parametrics
Work on metaprogramming doodles
Start designing the type system
##

# Syntax for defining algebraic data types
	# Special context needed because ADTs are a collection of constructors, not types
type Option[T] = Some(T) | None


# Syntax for defining custom structures
let Animal = { ... }

# Syntax for defining parametric structures
let Vec[T] = (n: Size) {
	# T must be a type (ie. "T: Type", the ": Type" is filled in by default)
}

# Dependent Typing Syntax ???
let Vec[T, n: Size] = { ... }		# Values can be part of the parameter system
					# Does this enable dependent typing ???


# Local type alias (local types also allowed)
using Reducable = Numeric | Traversable


# Other Parametric stuff
[T: ^Numeric]			# T can't be Numeric
[T: Numeric | Traversable]	# T must be Numeric or Traversable
[T: Reducable]			# Same as above


# Create a type with a constructor that takes a String
let Person = (name: String) {
	static count mut = 0				# Mutable static field (mutable syntax uncertain)

	def this = (:Person) .name.this			# Variable-less copy constructor
	def hello = println("Hello! I'm {name}!")	# Method? With interpolation
							# What differentiates this from assigning to the result of an equation (see "variables" below)
}

# Standard Types
Size		# unsigned
Int		# signed
Float		# double


# Spero Design Sheet: Caeser

# Define Cipher trait (a type with unimplemented members)
let Cipher[T] = {
	let Enc = T{}
	def encode = (T*) => Enc*	# The current syntax I'm experimenting on
	def decode = (Enc*) => T*	# Function signatures
}

# Should subtypes have to specify types of inherited functions ??
let Caeser = (shft: Char) {
	use Cipher[Char]

	def encode = .map (+ shft)
	def decode = .map (- shft)
}


# Lambda Types and Inheritance
let caeser = Cipher[Char]{ ... }	# caeser is actually an instance of Cipher
let caeser = { use Cipher[Char] ... }	# same thing as above (above is sugar for this)


# Subtyping/Type restrictions
def foo = (x) { ... }		# args must support all methods called on x (but what differentiates this from a tuple with the value of x ???)
def foo = (x: Numeric) { ... }	# args must inherit from Numeric (+ method support)
				# unless this isn't how inferrence works

# Metaprogramming
(Int, Float, String).filter(Numeric).size
